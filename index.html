<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JumpTek MediaPipe AI Tracker Widget</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.16.0/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.16.0/dist/tf-converter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.16.0/dist/tf-backend-webgl.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #333;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: black;
            overflow: hidden;
        }

        video, canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensure video fits without cropping */
            transform: scaleX(-1); /* Mirror the video */
            z-index: 1;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none; /* Allow clicks to pass through by default */
        }

        #top-bar {
            display: flex;
            justify-content: center;
            padding: 10px;
            pointer-events: auto; /* Re-enable pointer events for buttons */
        }

        #bottom-bar {
            padding: 10px;
            text-align: center;
            pointer-events: auto; /* Re-enable pointer events for notice */
        }

        .jump-display {
            font-size: 8em; /* Large font size for jump height */
            font-weight: bold;
            color: #00ff00; /* Green color for positive height */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-top: 50px;
            text-align: center;
            z-index: 3;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        button {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #00f;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin: 0 5px;
            transition: background-color 0.2s, border-color 0.2s;
            pointer-events: auto; /* Ensure buttons are clickable */
        }

        button:hover {
            background-color: rgba(0, 0, 0, 0.8);
            border-color: #0ff;
        }

        button img {
            width: 30px;
            height: 30px;
            filter: invert(1); /* Make icons white */
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
        }

        #settingsPopover {
            position: absolute;
            top: 60px; /* Adjust as needed to be below settings button */
            right: 10px;
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 20px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            z-index: 10;
            pointer-events: auto;
            min-width: 250px;
        }

        #settingsPopover.open {
            display: flex;
        }

        #settingsPopover label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        #settingsPopover input[type="number"],
        #settingsPopover input[type="range"] {
            width: 60%;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: #eee;
        }

        #settingsPopover .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }

        #settingsPopover button {
            width: auto;
            height: auto;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #settingsPopover button.close-btn {
            background-color: #6c757d;
        }
        #settingsPopover button:hover {
            background-color: #0056b3;
        }
        #settingsPopover button.close-btn:hover {
            background-color: #5a6268;
        }

        #trampolineNotice {
            font-size: 1.2em;
            color: #fff; /* Default white */
            padding: 10px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #calibrationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4; /* Above video/canvas but below UI */
            pointer-events: auto; /* Important for clicking to mark corners */
        }

        .corner-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 255, 0, 0.7); /* Yellow */
            border-radius: 50%;
            transform: translate(-50%, -50%); /* Center the circle on the click */
            z-index: 5;
            pointer-events: none; /* So it doesn't block clicks after placement */
        }
        .debug-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #00ff00;
            padding: 8px;
            font-family: monospace;
            font-size: 0.9em;
            border-radius: 5px;
            pointer-events: none;
            z-index: 5; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
        }
        .debug-display.positive {
            color: #ff0; /* Yellow for positive values */
        }
        #frameRateDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #00ff00;
            padding: 8px;
            font-family: monospace;
            font-size: 0.9em;
            border-radius: 5px;
            pointer-events: none;
            z-index: 5; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
        }
        #zoomControls {
            position: absolute;
            right: 10px;
            bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto; /* Enable interaction */
            z-index: 3;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>

        <div id="ui-overlay">
            <div id="top-bar">
                <button id="switchCameraBtn" aria-label="Switch camera" tabindex="0" role="button">
                    <img src="https://static-00.iconduck.com/assets.00/camera-switch-icon-1024x1024-9oe5epjn.png" alt="Switch Camera">
                </button>
                <button id="calibrateBtn" aria-label="Calibrate baseline" tabindex="0" role="button">
                    <img src="https://icon-library.com/images/wrench-icon-png/wrench-icon-png-11.jpg" alt="Calibrate" style="width:28px;height:28px;" />
                </button>
                <button class="settings-btn" id="settingsBtn" aria-label="Open settings" tabindex="0" role="button">
                    <img src="https://icon-library.com/images/settings-icon-png/settings-icon-png-27.jpg" alt="Settings" style="width:28px;height:28px;" />
                </button>
            </div>

            <div class="jump-display" id="jumpHeightDisplay">0.00m</div>

            <div id="bottom-bar">
                <div id="trampolineNotice">Initializing...</div>
            </div>

            <div id="settingsPopover">
                <h3>Settings</h3>
                <label>
                    Camera Distance (m):
                    <input type="number" id="cameraDistance" value="2.0" step="0.1" min="0.1" max="10.0">
                </label>
                <label>
                    Camera Height (m):
                    <input type="number" id="cameraHeight" value="1.0" step="0.1" min="0.1" max="5.0">
                </label>
                <label>
                    Depth Scale Factor:
                    <input type="range" id="depthScaleFactor" value="5.0" min="1.0" max="20.0" step="0.1">
                </label>
                <label>
                    Debug Mode:
                    <input type="checkbox" id="debugModeCheckbox">
                </label>
                <div class="button-group">
                    <button class="close-btn" id="closeSettingsBtn">Close</button>
                    <button id="saveSettingsBtn">Save</button>
                </div>
            </div>

            <div id="calibrationOverlay"></div>

            <div id="rawHeightDebugDisplay" class="debug-display"></div>
            <div id="frameRateDisplay" class="debug-display" style="top: 10px; left: 10px;">FPS: 0</div>
            <div id="debugValuesDisplay" class="debug-display" style="top: 50%; transform: translateY(-50%); left: 10px;"></div>

            <div id="zoomControls">
                <button id="zoomInBtn" aria-label="Zoom In">
                    <img src="https://www.iconpacks.net/icons/2/free-zoom-in-icon-2615-thumb.png" alt="Zoom In">
                </button>
                <button id="zoomOutBtn" aria-label="Zoom Out">
                    <img src="https://www.iconpacks.net/icons/2/free-zoom-out-icon-2616-thumb.png" alt="Zoom Out">
                </button>
            </div>
        </div>
    </div>

    <script type="module">
    // Corrected MediaPipe Library Imports
    import { Pose, POSE_CONNECTIONS } from 'https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js';
    import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera/camera.js';
    import { drawConnectors, drawLandmarks } from 'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js';

    // --- DOM Elements ---
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const jumpHeightDisplay = document.getElementById('jumpHeightDisplay');
    const trampolineNotice = document.getElementById('trampolineNotice');
    const calibrateBtn = document.getElementById('calibrateBtn');
    const calibrationOverlay = document.getElementById('calibrationOverlay');
    const rawHeightDebugDisplay = document.getElementById('rawHeightDebugDisplay');
    const frameRateDisplay = document.getElementById('frameRateDisplay');
    const debugValuesDisplay = document.getElementById('debugValuesDisplay');
    const debugModeCheckbox = document.getElementById('debugModeCheckbox');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');

    // --- Global Variables ---
    let useFrontCamera = false;
    let currentStream = null;
    let pose;
    let camera;
    let lastPoseResults = null;
    let lastRenderTime = performance.now();
    let debugMode = false;
    let videoTrack = null; // To store the video track for zoom controls
    let zoomCapabilities = null; // To store zoom min, max, step

    // --- Calibration Variables ---
    const CALIBRATION_PHASE_MARK_CORNERS = 0;
    const CALIBRATION_PHASE_STAND_STILL = 1;
    const CALIBRATION_PHASE_JUMP_CALIBRATION = 2;
    const CALIBRATION_PHASE_COMPLETE = 3;
    let currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
    let trampolineCorners = []; // Stores pixel coordinates [x, y]
    let trampolinePolygon = null; // Stores world coordinates of the polygon
    let calibrationReady = false;
    let baselineZ = null; // Baseline Z (depth) for the trampoline surface
    let calibrationZValues = []; // Array to store Z values during stand-still calibration
    let calibrationSamples = 0;
    const calibrationDurationMs = 5000; // 5 seconds for stand-still calibration
    const calibrationIntervalMs = 50;   // Sample every 50ms (20 samples per second)
    const maxCalibrationSamples = calibrationDurationMs / calibrationIntervalMs;

    const REQUIRED_CALIBRATION_JUMPS = 3; // Number of jumps required for Z-scale calibration
    let calibrationJumpsData = []; // Stores {h3d, hflight} for jump calibration

    // --- Jump Tracking State Machine ---
    const JUMP_STATE_ON_TRAMPOLINE = 'ON_TRAMPOLINE';
    const JUMP_STATE_AIRBORNE = 'AIRBORNE';
    const JUMP_STATE_DESCENDING = 'DESCENDING';
    let jumpState = JUMP_STATE_ON_TRAMPOLINE;
    let takeOffTime = 0; // Timestamp of takeoff
    let highestPointZ = -Infinity; // Highest Z coordinate reached during a jump (deeper is higher)
    let flightTime = 0; // Total flight time for a jump

    // --- Smoothing variables ---
    let currentZSmoothed = null;
    let verticalVelocitySmoothed = null;
    let lastFpsUpdateTime = 0; // For FPS calculation

    // --- Camera Setup ---
    async function startCamera() {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
        }

        try {
            const constraints = {
                video: {
                    facingMode: useFrontCamera ? 'user' : 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = currentStream;

            videoTrack = currentStream.getVideoTracks()[0];
            const capabilities = videoTrack.getCapabilities();

            if (capabilities.zoom) {
                zoomCapabilities = capabilities.zoom;
                zoomInBtn.disabled = false;
                zoomOutBtn.disabled = false;
            } else {
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
                zoomCapabilities = null;
                console.warn("Zoom not supported by this camera.");
            }

            return new Promise((resolve) => {
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    console.log(`[CAMERA] Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                    resolve();
                };
            });
        } catch (error) {
            console.error('Error accessing camera:', error);
            trampolineNotice.textContent = "Error: Could not access camera. Please ensure camera permissions are granted.";
            trampolineNotice.style.color = '#f00';
            calibrateBtn.disabled = true;
            settingsBtn.disabled = true;
        }
    }

    // --- MediaPipe Pose Setup ---
    function setupMediaPipe() {
        pose = new Pose({
            locateFile: (file) => {
                // Corrected path for MediaPipe assets
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1, // 0, 1, 2. Higher is more accurate but slower.
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        camera.start();
        console.log("[MEDIAPIPE] Pose model initialized.");
    }

    // --- Drawing Loop ---
    function onResults(results) {
        lastPoseResults = results; // Store results for other functions

        // Calculate FPS
        const currentTime = performance.now();
        const deltaTime = currentTime - lastRenderTime;
        lastRenderTime = currentTime;
        const fps = 1000 / deltaTime;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        // Draw pose landmarks and connections
        if (results.poseLandmarks) {
            drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
            drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 2 });
        }

        // Draw trampoline polygon if defined
        if (trampolineCorners.length === 4) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(trampolineCorners[0].x, trampolineCorners[0].y);
            for (let i = 1; i < trampolineCorners.length; i++) {
                canvasCtx.lineTo(trampolineCorners[i].x, trampolineCorners[i].y);
            }
            canvasCtx.closePath();
            canvasCtx.strokeStyle = 'yellow';
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
        }

        canvasCtx.restore();

        // Update UI based on calibration phase
        updateUI(fps);
    }

    function updateUI(fps) {
        // Update FPS display if debug mode is active
        if (debugMode) {
            frameRateDisplay.textContent = `FPS: ${fps.toFixed(1)}`;
        }

        if (currentCalibrationPhase === CALIBRATION_PHASE_MARK_CORNERS) {
            trampolineNotice.textContent = `Please mark the 4 corners of your trampoline. (${trampolineCorners.length}/4)`;
            trampolineNotice.style.color = '#fff';
            calibrateBtn.style.display = "none";
        } else if (currentCalibrationPhase === CALIBRATION_PHASE_STAND_STILL) {
            if (trampolineNotice.textContent.indexOf("CALIBRATING...") === -1) { // Don't override calibration messages
                trampolineNotice.textContent = "Trampoline area set! Stand still on the trampoline and press Calibrate.";
                trampolineNotice.style.color = '#0ff';
            }
            calibrateBtn.style.display = "block";
            // ONLY enable the calibrate button if a pose is detected AND we are in the STAND_STILL phase
            const canEnableCalibrate = (currentCalibrationPhase === CALIBRATION_PHASE_STAND_STILL && lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0);
            calibrateBtn.disabled = !canEnableCalibrate;
            // console.log(`[DRAW] Calibrate Btn Display: block, Disabled: ${calibrateBtn.disabled} (Can Enable: ${canEnableCalibrate})`); // Debugging line
        } else if (currentCalibrationPhase === CALIBRATION_PHASE_JUMP_CALIBRATION) {
            calibrateBtn.style.display = "none"; // Hide calibrate button during jump calibration
            // Notice text handled in computeAndSendJump
        } else if (currentCalibrationPhase === CALIBRATION_PHASE_COMPLETE) {
            trampolineNotice.textContent = "Calibration Complete! Jump height tracking active.";
            trampolineNotice.style.color = '#0f0';
            calibrateBtn.style.display = "none";
        }
    }

    // --- Coordinate Transformation ---
    // These matrices are placeholders. A proper calibration would involve solving
    // for these based on known 3D points and their 2D projections.
    // For this example, we're assuming a simple perspective setup.
    // C: Camera position in world coordinates (x, y, z)
    // R: Rotation matrix for camera orientation (identity for no rotation)
    // fx, fy: Focal lengths, cx, cy: Principal point
    window._JT_intrinsics = { fx: 0, fy: 0, cx: 0, cy: 0 }; // Initialized based on canvas size later
    window._JT_extrinsics = { C: [0, 0, 0], R: [[1,0,0],[0,1,0],[0,0,1]] };
    window._JT_plane = { normal: [0,0,1], point: [0,0,0] }; // Trampoline plane: z=0, normal pointing up

    function pixelToWorld(px, py, landmarkZ) {
        const { fx, fy, cx, cy } = window._JT_intrinsics;
        const { C, R } = window._JT_extrinsics; // Camera position and rotation

        // Convert pixel coordinates to normalized image coordinates
        const x_norm = (px - cx) / fx;
        const y_norm = (py - cy) / fy;

        // MediaPipe's Z is relative depth, scale it to meters
        // Positive Z from MediaPipe means further away from camera.
        // We want Z in world coordinates where larger Z means higher off the trampoline.
        // The relationship between MediaPipe's 'z' and world Z is complex,
        // but we can scale it.
        const mp_z_scaled = landmarkZ * depthScaleFactor;

        // Assuming camera is looking mostly straight, depth is related to Z in world.
        // This is a simplification. A full perspective transformation is more involved.
        // For simple setup: Z in world = camera Z - (scaled_mp_z_value)
        // With depthScaleFactor, we are effectively scaling the depth received from MediaPipe
        // to approximate a real-world distance.

        // World coordinates relative to camera (simplified perspective projection)
        // This assumes landmarkZ from MediaPipe is a depth value.
        // Smallest MediaPipe Z (closer to camera) should correspond to larger world Z (higher up)
        const Z_world = mp_z_scaled; // Map MediaPipe's Z directly as a relative depth

        // This is a highly simplified camera model.
        // A more rigorous approach involves inverse projection:
        // [X_c, Y_c, Z_c] = Z_depth * inv(K) * [x_norm, y_norm, 1]
        // [X_w, Y_w, Z_w] = R_inv * ( [X_c, Y_c, Z_c] - C )

        // Given MediaPipe provides Z relative to camera, and we're dealing with
        // a fixed camera setup relative to the trampoline, we primarily care
        // about mapping the *change* in MediaPipe's Z to *change* in jump height.

        // For now, let's just return a placeholder based on MediaPipe's Z
        // We'll primarily rely on baselineZ and depthScaleFactor for height calculation.
        // The x, y world coordinates would typically be found through more complex geometry.
        // For this specific use case (vertical jump), the Z component is most critical.

        // The "worldPt" here is simplified. We use MediaPipe's Z directly,
        // scaled by depthScaleFactor, as the height relative to the camera.
        // The actual Z used for jump height will be relative to baselineZ.
        return [0, 0, Z_world];
    }

    // --- Trampoline Area Marking ---
    calibrationOverlay.addEventListener('click', (event) => {
        if (currentCalibrationPhase === CALIBRATION_PHASE_MARK_CORNERS) {
            const rect = canvasElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const canvasX = (x / rect.width) * canvasElement.width;
            const canvasY = (y / rect.height) * canvasElement.height;

            if (trampolineCorners.length < 4) {
                trampolineCorners.push({ x: canvasX, y: canvasY });
                // Add a visual marker on the overlay
                const marker = document.createElement('div');
                marker.classList.add('corner-marker');
                marker.style.left = `${event.clientX}px`;
                marker.style.top = `${event.clientY}px`;
                calibrationOverlay.appendChild(marker);
            }

            if (trampolineCorners.length === 4) {
                // Once 4 corners are marked, transition to stand-still calibration
                currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL;
                calibrationOverlay.style.pointerEvents = 'none'; // Disable further clicks on overlay
                trampolineNotice.textContent = "Trampoline area set! Stand still on the trampoline and press Calibrate.";
                calibrateBtn.style.display = "block"; // Make calibrate button visible
                console.log("[CALIBRATION] Trampoline corners set:", trampolineCorners);

                // Convert pixel corners to "world" coordinates (simplified for now)
                // This polygon might not be truly world coordinates yet, but pixel-based.
                // We'll use this for visual representation.
                trampolinePolygon = trampolineCorners.map(p => {
                    // For now, just a placeholder. True world conversion happens in pixelToWorld.
                    // This polygon is mainly for drawing the rectangle.
                    return [p.x, p.y, 0]; // z=0 placeholder
                });
            }
        }
    });

    // --- Stand-Still Calibration Logic ---
    let poseCheckRetries = 0;
    const MAX_POSE_CHECK_RETRIES = 10; // Try for about 5 seconds (10 * 500ms)

    const checkPoseAndStartCalibration = () => {
        if (lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0) {
            const lowestLandmark = getLowestBodyLandmark(lastPoseResults.poseLandmarks);
            if (lowestLandmark) {
                console.log("[CALIBRATION_INIT] Pose detected and suitable landmark found. Starting stand-still calibration...");
                poseCheckRetries = 0; // Reset retry counter on success
                startStandStillCalibration();
            } else {
                poseCheckRetries++;
                if (poseCheckRetries < MAX_POSE_CHECK_RETRIES) {
                    trampolineNotice.style.color = '#ff0';
                    trampolineNotice.textContent = `Please ensure your ankles/hips are clearly visible and still. Retrying pose detection... (${poseCheckRetries}/${MAX_POSE_CHECK_RETRIES})`;
                    console.warn(`[CALIBRATION_INIT] Pose detected, but no reliable low landmark found for calibration. Retrying... (${poseCheckRetries})`);
                    setTimeout(checkPoseAndStartCalibration, 500); // Retry after 500ms
                } else {
                    trampolineNotice.style.color = '#f00';
                    trampolineNotice.textContent = "Failed to detect a stable pose for calibration after multiple attempts. Ensure good lighting and full body visibility.";
                    console.error("[CALIBRATION_INIT] Max pose detection retries reached. Calibration aborted.");
                    calibrateBtn.disabled = false; // Re-enable button to allow user to retry manually
                    poseCheckRetries = 0; // Reset for next attempt
                }
            }
        } else {
            // This branch is for no pose results at all (MediaPipe not seeing anyone)
            poseCheckRetries++;
            if (poseCheckRetries < MAX_POSE_CHECK_RETRIES) {
                trampolineNotice.style.color = '#ff0';
                trampolineNotice.textContent = `No body detected. Please ensure your full body is in view. Retrying pose detection... (${poseCheckRetries}/${MAX_POSE_CHECK_RETRIES})`;
                console.warn(`[CALIBRATION_INIT] No pose data for calibration. Retrying... (${poseCheckRetries})`);
                setTimeout(checkPoseAndStartCalibration, 500); // Retry after 500ms
            } else {
                trampolineNotice.style.color = '#f00';
                trampolineNotice.textContent = "No body detected after multiple attempts. Ensure camera is working and you are visible.";
                console.error("[CALIBRATION_INIT] Max pose detection retries reached. Calibration aborted due to no pose data.");
                calibrateBtn.disabled = false; // Re-enable button
                poseCheckRetries = 0; // Reset
            }
        }
    };


    const startStandStillCalibration = () => {
        calibrateBtn.disabled = true; // Disable button during calibration
        calibrationZValues = [];
        calibrationSamples = 0;
        trampolineNotice.style.color = '#fff'; // Reset color

        // Initialize camera and plane settings before stand-still calibration
        cameraDistanceMeters = parseFloat(cameraDistanceInput.value) || 2.0;
        cameraHeightMeters = parseFloat(cameraHeightInput.value) || 1.0;
        depthScaleFactor = parseFloat(depthScaleFactorInput.value) || 5.0;

        window._JT_intrinsics = {
            fx: Math.min(canvasElement.width, canvasElement.height) * 0.8, // Approximation for focal length
            fy: Math.min(canvasElement.width, canvasElement.height) * 0.8,
            cx: canvasElement.width / 2,
            cy: canvasElement.height / 2
        };

        window._JT_extrinsics = {
            C: [0, -cameraDistanceMeters, cameraHeightMeters],
            R: [[1,0,0],[0,1,0],[0,0,1]]
        };

        window._JT_plane = {
            normal: [0,0,1],
            point: [0,0,0]
        };

        const calibrationLoop = setInterval(() => {
            if (lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0) {
                const lowestLandmark = getLowestBodyLandmark(lastPoseResults.poseLandmarks);

                if (lowestLandmark) {
                    const lx = lowestLandmark.x * canvasElement.width;
                    const ly = lowestLandmark.y * canvasElement.height;
                    const worldPtBaselineSample = pixelToWorld(lx, ly, lowestLandmark.z);
                    calibrationZValues.push(worldPtBaselineSample[2]);
                    calibrationSamples++;
                    trampolineNotice.textContent = `CALIBRATING... Stand still on the trampoline for ${((calibrationDurationMs - (calibrationSamples * calibrationIntervalMs)) / 1000).toFixed(1)}s.`;
                    console.log(`[CALIBRATION_LOOP] Sampled Z: ${worldPtBaselineSample[2].toFixed(3)}m. Samples: ${calibrationSamples}`);
                } else {
                    trampolineNotice.textContent = `CALIBRATING... (Pose lost or not detected) Please ensure ankles/hips are visible. ${((calibrationDurationMs - (calibrationSamples * calibrationIntervalMs)) / 1000).toFixed(1)}s remaining.`;
                    trampolineNotice.style.color = '#ff0'; // Change to warning color
                    console.warn("[CALIBRATION_LOOP] No suitable low landmark found for this sample.");
                }
            } else {
                trampolineNotice.textContent = `CALIBRATING... (No Pose Data) Please ensure your body is visible. ${((calibrationDurationMs - (calibrationSamples * calibrationIntervalMs)) / 1000).toFixed(1)}s remaining.`;
                trampolineNotice.style.color = '#ff0'; // Change to warning color
                console.warn("[CALIBRATION_LOOP] No pose data for this sample.");
            }

            if (calibrationSamples >= maxCalibrationSamples) {
                clearInterval(calibrationLoop);

                if (calibrationZValues.length > 0) {
                    // Filter outliers from calibrationZValues using IQR method
                    const sortedZ = [...calibrationZValues].sort((a,b) => a - b);
                    const q1 = sortedZ[Math.floor(sortedZ.length * 0.25)];
                    const q3 = sortedZ[Math.ceil(sortedZ.length * 0.75) -1];
                    const iqr = q3 - q1;
                    const lowerBound = q1 - 1.5 * iqr;
                    const upperBound = q3 + 1.5 * iqr;

                    const filteredZValues = calibrationZValues.filter(z => z >= lowerBound && z <= upperBound);

                    if (filteredZValues.length > 0) {
                        const sumZ = filteredZValues.reduce((a, b) => a + b, 0);
                        baselineZ = sumZ / filteredZValues.length;
                        console.log(`[CALIBRATION_COMPLETE] Calibrated trampoline Z baseline (averaged, filtered): ${baselineZ.toFixed(3)}m`);

                        currentCalibrationPhase = CALIBRATION_PHASE_JUMP_CALIBRATION;
                        calibrationJumpsData = []; // Clear previous jump data
                        trampolineNotice.style.color = '#0f0';
                        trampolineNotice.textContent = `Baseline set! Now perform ${REQUIRED_CALIBRATION_JUMPS} jumps for Z-scale calibration.`;
                        calibrateBtn.style.display = "none"; // Hide calibrate button during jump calibration
                        jumpState = JUMP_STATE_ON_TRAMPOLINE; // Reset jump state for new phase
                        currentZSmoothed = null; // Reset smoothing for new phase
                        verticalVelocitySmoothed = null;
                    } else {
                        trampolineNotice.style.color = '#f00';
                        trampolineNotice.textContent = "Calibration failed: No valid baseline data after filtering. Try again from a stable position.";
                        baselineZ = null;
                        currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL;
                        calibrateBtn.disabled = false;
                        console.error("[CALIBRATION_COMPLETE] No valid baseline data after filtering.");
                    }
                } else {
                    trampolineNotice.style.color = '#f00';
                    trampolineNotice.textContent = "Calibration failed: No valid baseline data collected. Make sure your ankles/hips are visible and still.";
                    baselineZ = null;
                    currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL; // Go back to stand still phase
                    calibrateBtn.disabled = false; // Re-enable to retry
                    console.error("[CALIBRATION_COMPLETE] No valid baseline data collected at all.");
                }
            }
        }, calibrationIntervalMs);
    };

    // --- Calibrate Button Event Listener ---
    calibrateBtn.addEventListener('click', async function() {
        console.log(`[CALIBRATE_BTN_CLICK] Clicked! Current Phase: ${currentCalibrationPhase}`);

        if (currentCalibrationPhase === CALIBRATION_PHASE_STAND_STILL) {
            if (!trampolinePolygon) {
                trampolineNotice.style.color = '#f00';
                trampolineNotice.textContent = "Error: Please mark the 4 corners of the trampoline first.";
                console.error("[CALIBRATE_BTN_CLICK] Calibration attempted without trampoline polygon.");
                return;
            }
            checkPoseAndStartCalibration(); // Initiate the robust pose check
        }
    });

    // --------- SETTINGS POPOVER LOGIC ---------
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPopover = document.getElementById('settingsPopover');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');

    settingsBtn.addEventListener('click', e => {
        e.stopPropagation();
        settingsPopover.classList.toggle('open');
    });
    closeSettingsBtn.addEventListener('click', () => settingsPopover.classList.remove('open'));
    document.addEventListener('mousedown', e => {
        if (settingsPopover.classList.contains('open') &&
            !settingsPopover.contains(e.target) &&
            e.target !== settingsBtn) {
            settingsPopover.classList.remove('open');
        }
    });

    // --------- SAVE/LOAD SETTINGS ---------
    const cameraDistanceInput = document.getElementById('cameraDistance');
    const cameraHeightInput = document.getElementById('cameraHeight');
    const depthScaleFactorInput = document.getElementById('depthScaleFactor');

    function applyDebugMode() {
        if (debugMode) {
            rawHeightDebugDisplay.style.display = 'block';
            frameRateDisplay.style.display = 'block'; // Show FPS in debug mode
            debugValuesDisplay.style.display = 'block';
        } else {
            rawHeightDebugDisplay.style.display = 'none';
            frameRateDisplay.style.display = 'none';
            debugValuesDisplay.style.display = 'none';
        }
    }

    function saveSettingsToStorage() {
        localStorage.setItem('jt_cameraDistance', cameraDistanceInput.value);
        localStorage.setItem('jt_cameraHeight', cameraHeightInput.value);
        localStorage.setItem('jt_depthScaleFactor', depthScaleFactorInput.value);
        localStorage.setItem('jt_debugMode', debugModeCheckbox.checked ? 'true' : 'false');
        console.log("[SETTINGS] Settings saved to local storage.");
    }
    function loadSettingsFromStorage() {
        ['jt_cameraDistance','jt_cameraHeight', 'jt_depthScaleFactor'].forEach(k => {
            const v = localStorage.getItem(k);
            if (v !== null) {
                document.getElementById({
                    'jt_cameraDistance':'cameraDistance',
                    'jt_cameraHeight':'cameraHeight',
                    'jt_depthScaleFactor':'depthScaleFactor'
                }[k]).value = v;
            }
        });

        const loadedDebugMode = localStorage.getItem('jt_debugMode');
        debugMode = (loadedDebugMode === 'true');
        debugModeCheckbox.checked = debugMode;
        applyDebugMode();
        console.log("[SETTINGS] Settings loaded from local storage.");

        ['cameraDistance','cameraHeight', 'depthScaleFactor'].forEach(id =>
            document.getElementById(id).dispatchEvent(new Event('input'))
        );
    }

    saveSettingsBtn.addEventListener('click', () => {
        saveSettingsToStorage();
        debugMode = debugModeCheckbox.checked;
        applyDebugMode();
        // If settings are changed, it implies current calibration might be invalid
        // Reset to mark corners phase to force full recalibration
        currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
        calibrationReady = false;
        baselineZ = null;
        trampolinePolygon = null;
        trampolineCorners = [];
        // Clear all existing markers from the calibrationOverlay
        while (calibrationOverlay.firstChild) {
            calibrationOverlay.removeChild(calibrationOverlay.firstChild);
        }

        trampolineNotice.textContent = "Settings changed. Please re-mark trampoline corners and re-calibrate.";
        calibrateBtn.style.display = "none"; // Hide until corners are marked
        saveSettingsBtn.textContent = 'Saved!';
        setTimeout(() => saveSettingsBtn.textContent = 'Save', 1200);
        // Reset smoothing when settings change
        currentZSmoothed = null;
        verticalVelocitySmoothed = null;
        console.log("[SETTINGS] Settings saved. Calibration reset required.");
    });
    window.addEventListener('DOMContentLoaded', loadSettingsFromStorage);

    // --------- CONFIGURABLE PARAMETERS ---------
    let cameraDistanceMeters = parseFloat(localStorage.getItem('jt_cameraDistance')) || 2.0;
    let cameraHeightMeters = parseFloat(localStorage.getItem('jt_cameraHeight')) || 1.0;
    let depthScaleFactor = parseFloat(localStorage.getItem('jt_depthScaleFactor')) || 5.0; // Starting value, will be tuned

    // --- Smoothing Parameters ---
    const ALPHA_Z_SMOOTHING = 0.4; // Higher alpha means less smoothing (0-1)
    const ALPHA_VELOCITY_SMOOTHING = 0.3; // Higher alpha means less smoothing (0-1)

    // --- Jump Detection Thresholds (tweaked for robustness) ---
    const MIN_JUMP_DISPLAY_THRESHOLD = 0.05; // Minimum height to display as a jump
    const GRAVITY = 9.81; // m/s^2

    // Thresholds for jump detection (in meters)
    const JUMP_OFF_TRAMPOLINE_THRESHOLD_METERS = 0.05; // How far above baseline to count as leaving trampoline
    const LANDING_ON_TRAMPOLINE_THRESHOLD_METERS = 0.03; // How close to baseline to count as landing

    // Velocity thresholds for jump state changes (m/s) - more robust
    const TAKEOFF_VELOCITY_THRESHOLD = 0.1; // Min positive velocity to confirm takeoff
    const PEAK_VELOCITY_THRESHOLD = -0.05; // Negative velocity indicating descent past peak
    const LANDING_VELOCITY_THRESHOLD = -0.2; // Max negative velocity at landing (can be slightly negative due to impact)

    cameraDistanceInput.addEventListener('input', () => {
        cameraDistanceMeters = parseFloat(cameraDistanceInput.value) || 2.0;
        console.log(`[INPUT] Camera Distance: ${cameraDistanceMeters}m`);
    });
    cameraHeightInput.addEventListener('input', () => {
        cameraHeightMeters = parseFloat(cameraHeightInput.value) || 1.0;
        console.log(`[INPUT] Camera Height: ${cameraHeightMeters}m`);
    });
    depthScaleFactorInput.addEventListener('input', () => {
        depthScaleFactor = parseFloat(depthScaleFactorInput.value) || 5.0;
        console.log(`[INPUT] Depth Scale Factor: ${depthScaleFactor}`);
    });

    // --------- CAMERA SWITCH & CLEANUP ---------
    switchCameraBtn.addEventListener('click', async () => {
        useFrontCamera = !useFrontCamera;
        await startCamera();
        // Reset full calibration on camera switch
        currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
        calibrationReady = false;
        baselineZ = null;
        trampolineNotice.textContent = "Camera switched. Please re-mark trampoline corners and re-calibrate.";
        calibrateBtn.style.display = "none";
        trampolineCorners = [];
        trampolinePolygon = null;
        // Clear all existing markers from the calibrationOverlay
        while (calibrationOverlay.firstChild) {
            calibrationOverlay.removeChild(calibrationOverlay.firstChild);
        }
        jumpState = JUMP_STATE_ON_TRAMPOLINE;
        highestPointZ = -Infinity;
        flightTime = 0;
        // Reset smoothing history
        currentZSmoothed = null;
        verticalVelocitySmoothed = null;
        console.log("[CAMERA_SWITCH] Camera switched. Calibration reset required.");
    });
    window.addEventListener('beforeunload', () => {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    });

    // --------- ZOOM CONTROLS ---------
    const resetCalibrationForZoom = () => {
        // Reset full calibration on zoom change
        currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
        calibrationReady = false;
        baselineZ = null;
        trampolineNotice.textContent = "Zoom changed. Please re-mark trampoline corners and re-calibrate.";
        calibrateBtn.style.display = "none";
        trampolineCorners = [];
        trampolinePolygon = null;
        // Clear all existing markers from the calibrationOverlay
        while (calibrationOverlay.firstChild) {
            calibrationOverlay.removeChild(calibrationOverlay.firstChild);
        }
        jumpState = JUMP_STATE_ON_TRAMPOLINE;
        highestPointZ = -Infinity;
        flightTime = 0;
        // Reset smoothing history
        currentZSmoothed = null;
        verticalVelocitySmoothed = null;
        console.log("[ZOOM] Zoom changed. Calibration reset required.");
    };

    zoomInBtn.addEventListener('click', async () => {
        if (!videoTrack || !zoomCapabilities) return;
        const currentZoom = videoTrack.getSettings().zoom || zoomCapabilities.min;
        const newZoom = Math.min(zoomCapabilities.max, currentZoom + (zoomCapabilities.step || 0.1)); // Fallback for step
        try {
            await videoTrack.applyConstraints({ advanced: [{ zoom: newZoom }] });
            resetCalibrationForZoom();
        } catch (e) {
            console.error("Failed to set zoom:", e);
        }
    });

    zoomOutBtn.addEventListener('click', async () => {
        if (!videoTrack || !zoomCapabilities) return;
        const currentZoom = videoTrack.getSettings().zoom || zoomCapabilities.min;
        const newZoom = Math.max(zoomCapabilities.min, currentZoom - (zoomCapabilities.step || 0.1)); // Fallback for step
        try {
            await videoTrack.applyConstraints({ advanced: [{ zoom: newZoom }] });
            resetCalibrationForZoom();
        } catch (e) {
            console.error("Failed to set zoom:", e);
        }
    });

    // Initial state for zoom buttons
    zoomInBtn.disabled = true;
    zoomOutBtn.disabled = true;

    // Helper to get the lowest landmark (on screen Y) for tracking
    // Prioritizes ankles, then knees, then hips for robustness
    function getLowestBodyLandmark(landmarks) {
        // Define relevant lower body landmarks by their indices
        const relevantLandmarkIndices = [
            27, 28, // Left and Right Ankle
            25, 26, // Left and Right Knee
            23, 24  // Left and Right Hip
        ];

        let lowestLandmark = null;
        let lowestY = -Infinity; // Canvas Y-coordinate (higher is lower on screen)

        // A slightly more lenient confidence threshold for general tracking and initial calibration
        const CONFIDENCE_THRESHOLD = 0.5; // Changed from 0.6 to 0.5

        // Find the lowest point among all relevant landmarks that have a high enough confidence score
        for (const index of relevantLandmarkIndices) {
            const landmark = landmarks[index];
            if (landmark && landmark.score > CONFIDENCE_THRESHOLD) { // Use the adjusted confidence threshold
                // If it's the first confident landmark or lower than current lowest
                if (!lowestLandmark || landmark.y > lowestY) {
                    lowestY = landmark.y;
                    lowestLandmark = landmark;
                }
            }
        }

        // If no reliable lower body landmark is found, try other body parts like shoulders or nose,
        // though this is less ideal for jump tracking. Still use the same CONFIDENCE_THRESHOLD.
        if (!lowestLandmark) {
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftHip = landmarks[23]; // Re-check hips with fallback in case previous loop missed them due to initial conditions
            const rightHip = landmarks[24];


            // Prioritize hip if ankle/knee not found, before going to upper body
            if (leftHip && leftHip.score > CONFIDENCE_THRESHOLD && (!lowestLandmark || leftHip.y > lowestY)) {
                lowestLandmark = leftHip;
                lowestY = leftHip.y;
            }
            if (rightHip && rightHip.score > CONFIDENCE_THRESHOLD && (!lowestLandmark || rightHip.y > lowestY)) {
                lowestLandmark = rightHip;
                lowestY = rightHip.y;
            }


            if (nose && nose.score > CONFIDENCE_THRESHOLD && (!lowestLandmark || nose.y > lowestY)) {
                console.warn("[getLowestBodyLandmark] Falling back to Nose landmark (index 0).");
                lowestLandmark = nose;
                lowestY = nose.y;
            }
            if (leftShoulder && leftShoulder.score > CONFIDENCE_THRESHOLD && (!lowestLandmark || leftShoulder.y > lowestY)) {
                console.warn("[getLowestBodyLandmark] Falling back to Left Shoulder landmark (index 11).");
                lowestLandmark = leftShoulder;
                lowestY = leftShoulder.y;
            }
            if (rightShoulder && rightShoulder.score > CONFIDENCE_THRESHOLD && (!lowestLandmark || rightShoulder.y > lowestY)) {
                console.warn("[getLowestBodyLandmark] Falling back to Right Shoulder landmark (index 12).");
                lowestLandmark = rightShoulder;
                lowestY = rightShoulder.y;
            }
        }

        if (!lowestLandmark) {
            console.warn("[getLowestBodyLandmark] No reliable landmarks found for tracking. Ensure person is fully visible.");
        }

        return lowestLandmark;
    }


    // --------- COMPUTE & SEND JUMP HEIGHT ---------
    let lastZPosRaw = null; // Store raw Z for velocity calculation
    let lastTimeRaw = null; // Store time for velocity calculation

    function computeAndSendJump(landmarks) {
        const currentTime = performance.now();

        // Update FPS display if debug mode is active
        if (debugMode) {
            if (!lastFpsUpdateTime) lastFpsUpdateTime = currentTime; // Initialize
            // FPS is updated in drawLoop, no need to duplicate here
            // Update debug values display
            debugValuesDisplay.innerHTML = `Baseline Z: ${baselineZ !== null ? baselineZ.toFixed(3) : 'N/A'}<br>`;
            debugValuesDisplay.innerHTML += `Jump State: ${jumpState}<br>`;
            debugValuesDisplay.innerHTML += `Cal Phase: ${currentCalibrationPhase}<br>`;
        }

        // Exit early if not in a tracking or jump calibration phase, or if not calibrated
        if ((currentCalibrationPhase !== CALIBRATION_PHASE_COMPLETE && currentCalibrationPhase !== CALIBRATION_PHASE_JUMP_CALIBRATION) || baselineZ === null) {
            if (debugMode) {
                rawHeightDebugDisplay.textContent = 'Raw Z-Delta: N/A';
                rawHeightDebugDisplay.classList.remove('positive');
                debugValuesDisplay.innerHTML += 'Not fully calibrated for tracking.';
            }
            sendJumpHeight(0, false); // Send 0 and not calibrated status
            return;
        }

        const lowestLandmark = getLowestBodyLandmark(landmarks);

        if (!lowestLandmark) {
            if (debugMode) {
                rawHeightDebugDisplay.textContent = 'Raw Z-Delta: No Landmrk';
                rawHeightDebugDisplay.classList.remove('positive');
                debugValuesDisplay.innerHTML += 'No suitable low landmark found.';
            }
            sendJumpHeight(0, true); // Still calibrated, but no pose data this frame
            return;
        }

        const lx = lowestLandmark.x * canvasElement.width;
        const ly = lowestLandmark.y * canvasElement.height;

        const worldPt = pixelToWorld(lx, ly, lowestLandmark.z);
        const currentZRaw = worldPt[2]; // Raw Z position

        // --- Calculate Raw Vertical Velocity ---
        let verticalVelocityRaw = 0;
        if (lastZPosRaw !== null && lastTimeRaw !== null) {
            const deltaTime = (currentTime - lastTimeRaw) / 1000;
            if (deltaTime > 0) {
                verticalVelocityRaw = (currentZRaw - lastZPosRaw) / deltaTime;
            }
        }
        lastZPosRaw = currentZRaw;
        lastTimeRaw = currentTime;


        // --- Exponential Smoothing ---
        if (currentZSmoothed === null) {
            currentZSmoothed = currentZRaw;
            verticalVelocitySmoothed = verticalVelocityRaw;
        } else {
            currentZSmoothed = ALPHA_Z_SMOOTHING * currentZRaw + (1 - ALPHA_Z_SMOOTHING) * currentZSmoothed;
            verticalVelocitySmoothed = ALPHA_VELOCITY_SMOOTHING * verticalVelocityRaw + (1 - ALPHA_VELOCITY_SMOOTHING) * verticalVelocitySmoothed;
        }

        // Update highest point reached *during* airborne phase using smoothed Z
        if (jumpState === JUMP_STATE_AIRBORNE && currentZSmoothed > highestPointZ) {
            highestPointZ = currentZSmoothed;
        }

        if (debugMode) {
            rawHeightDebugDisplay.textContent = `Current Z: ${currentZSmoothed.toFixed(3)}m`;
            debugValuesDisplay.innerHTML += `Smoothed Z: ${currentZSmoothed.toFixed(3)}m<br>`;
            debugValuesDisplay.innerHTML += `Smoothed Vel: ${verticalVelocitySmoothed.toFixed(2)} m/s<br>`;
            debugValuesDisplay.innerHTML += `Raw Z: ${currentZRaw.toFixed(3)}m<br>`;
            debugValuesDisplay.innerHTML += `Raw Vel: ${verticalVelocityRaw.toFixed(2)} m/s<br>`;
            if (currentZSmoothed > baselineZ + 0.05) {
                rawHeightDebugDisplay.classList.add('positive');
            } else {
                rawHeightDebugDisplay.classList.remove('positive');
            }
        }

        // --- Jump State Machine with Hysteresis and Smoothed Values ---
        switch (jumpState) {
            case JUMP_STATE_ON_TRAMPOLINE:
                // Condition to go Airborne: Z is above baseline AND vertical velocity is positive
                if (currentZSmoothed > (baselineZ + JUMP_OFF_TRAMPOLINE_THRESHOLD_METERS) && verticalVelocitySmoothed > TAKEOFF_VELOCITY_THRESHOLD) {
                    jumpState = JUMP_STATE_AIRBORNE;
                    takeOffTime = currentTime;
                    highestPointZ = currentZSmoothed; // Initialize highest point with current smoothed Z
                    flightTime = 0;
                    if (debugMode) console.log(`[${currentTime.toFixed(0)}ms] Take-off detected!`);
                }
                sendJumpHeight(0, true); // Still on trampoline, send 0 height
                break;

            case JUMP_STATE_AIRBORNE:
                // Condition to go Descending: Vertical velocity becomes negative (past peak)
                if (verticalVelocitySmoothed < PEAK_VELOCITY_THRESHOLD) {
                    jumpState = JUMP_STATE_DESCENDING;
                    if (debugMode) console.log(`[${currentTime.toFixed(0)}ms] Peak/Descending detected.`);
                }
                // highestPointZ is updated continuously in global scope
                break;

            case JUMP_STATE_DESCENDING:
                // Condition to go On Trampoline: Z is back near baseline AND vertical velocity is low/positive (landing impact)
                // Use slightly different threshold for landing (hysteresis)
                if (currentZSmoothed <= (baselineZ + LANDING_ON_TRAMPOLINE_THRESHOLD_METERS) && verticalVelocitySmoothed > LANDING_VELOCITY_THRESHOLD) {
                    jumpState = JUMP_STATE_ON_TRAMPOLINE;
                    const landingTime = currentTime;
                    flightTime = (landingTime - takeOffTime) / 1000;

                    const calculatedJumpHeightFlight = (0.5 * GRAVITY * (flightTime / 2) * (flightTime / 2));
                    let finalReportedHeight = Math.max(0, calculatedJumpHeightFlight < MIN_JUMP_DISPLAY_THRESHOLD ? 0 : calculatedJumpHeightFlight);

                    // --- Z-Scale Factor Automation Logic ---
                    // Only calibrate with meaningful jumps (sufficient flight time)
                    if (currentCalibrationPhase === CALIBRATION_PHASE_JUMP_CALIBRATION && flightTime > 0.3) {
                        const current3DHeight = Math.max(0, highestPointZ - baselineZ); // Height derived from MediaPipe Z

                        if (current3DHeight > 0.01 && calculatedJumpHeightFlight > 0.01) { // Avoid division by zero/near zero
                            calibrationJumpsData.push({ h3d: current3DHeight, hflight: calculatedJumpHeightFlight });
                            console.log(`Calibration Jump ${calibrationJumpsData.length}: H3D=${current3DHeight.toFixed(2)}m, HFlight=${calculatedJumpHeightFlight.toFixed(2)}m`);
                            trampolineNotice.textContent = `Jump ${calibrationJumpsData.length} of ${REQUIRED_CALIBRATION_JUMPS} recorded. Keep jumping!`;

                            if (calibrationJumpsData.length >= REQUIRED_CALIBRATION_JUMPS) {
                                // Calculate average ratio and update depthScaleFactor
                                let sumRatios = 0;
                                for (const data of calibrationJumpsData) {
                                    sumRatios += data.hflight / data.h3d;
                                }
                                const averageRatio = sumRatios / calibrationJumpsData.length;
                                depthScaleFactor *= averageRatio; // Adjust depthScaleFactor
                                depthScaleFactorInput.value = depthScaleFactor.toFixed(1); // Update UI
                                saveSettingsToStorage(); // Save the new factor

                                currentCalibrationPhase = CALIBRATION_PHASE_COMPLETE;
                                calibrationReady = true;
                                trampolineNotice.style.color = '#0f0';
                                trampolineNotice.textContent = "Z-Scale calibrated! Jump height tracking active.";
                                console.log(`Automated depthScaleFactor updated to: ${depthScaleFactor.toFixed(1)}`);
                                calibrationJumpsData = []; // Clear for next potential recalibration
                            }
                        } else {
                            trampolineNotice.textContent = `Jump too small for calibration or invalid height data. Please jump higher. (${calibrationJumpsData.length}/${REQUIRED_CALIBRATION_JUMPS})`;
                            console.warn(`[CALIBRATION_JUMP] Jump too small or invalid for calibration. H3D: ${current3DHeight.toFixed(2)}, HFlight: ${calculatedJumpHeightFlight.toFixed(2)}`);
                        }
                    }

                    if (debugMode) {
                        console.log(`[${currentTime.toFixed(0)}ms] Landing detected! Flight Time: ${flightTime.toFixed(3)}s, Calculated Height: ${calculatedJumpHeightFlight.toFixed(2)}m`);
                        debugValuesDisplay.innerHTML += `Flight Time: ${flightTime.toFixed(3)}s<br>`;
                        debugValuesDisplay.innerHTML += `Calculated Height: ${calculatedJumpHeightFlight.toFixed(2)}m<br>`;
                        debugValuesDisplay.innerHTML += `H3D (peak-baseline): ${(highestPointZ - baselineZ).toFixed(2)}m<br>`;
                    }
                    sendJumpHeight(finalReportedHeight, true);

                    highestPointZ = -Infinity; // Reset for next jump
                }
                break;
        }
    }

    let lastSentJumpHeight = -1;

    function sendJumpHeight(height, calibratedStatus) {
        if (Math.abs(height - lastSentJumpHeight) > 0.005 || (height === 0 && lastSentJumpHeight !== 0)) {
            lastSentJumpHeight = height;
            window.parent.postMessage({
                type: 'jump_height',
                height: height,
                calibrated: calibratedStatus,
                hd_deduction: 0 // Keep for compatibility if used elsewhere
            }, '*');
        }
    }

    // Processing interval for jump height calculation (at a lower rate than MP results for performance)
    setInterval(() => {
        // Only process pose if we are in a tracking or jump calibration phase and have results
        if ((currentCalibrationPhase === CALIBRATION_PHASE_COMPLETE || currentCalibrationPhase === CALIBRATION_PHASE_JUMP_CALIBRATION) && lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0) {
            computeAndSendJump(lastPoseResults.poseLandmarks);
        } else {
            // If not in a processing phase or no valid landmarks, ensure smoothing state is reset
            // This is important if we go from a tracked state to a non-tracked state
            if (currentZSmoothed !== null) {
                currentZSmoothed = null;
                verticalVelocitySmoothed = null;
                if (debugMode) console.log("[COMPUTE_LOOP] Resetting smoothed values due to non-tracking state or no landmarks.");
            }
            // Ensure jump height display updates even if not actively tracking
            jumpHeightDisplay.textContent = baselineZ !== null ? "Calibrated" : "Initializing...";
            jumpHeightDisplay.style.color = baselineZ !== null ? "#0f0" : "#fff";
        }
    }, 33); // Approximately 30 FPS for jump logic, balancing accuracy and performance

    // --- Initialize application ---
    async function init() {
        await startCamera();
        setupMediaPipe();
        trampolineNotice.textContent = "Please mark the 4 corners of your trampoline.";
    }

    init();

    </script>
</body>
</html>
