<script>
  // ===============================
  // Initialization and Global Variables
  // ===============================
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const switchCameraBtn = document.getElementById('switchCameraBtn');
  const loadingIndicator = document.getElementById('loadingIndicator'); // Optional: Add in HTML

  let currentStream = null;
  let useFrontCamera = false; // false = rear, true = front
  let isJumping = false;
  let jumpStart = 0;
  let animationFrameId;
  let parentOrigin = "YOUR_PARENT_ORIGIN"; // <--- Set this to your parent window's origin for security

  // ===============================
  // Pose Object Initialization
  // ===============================
  // Loads MediaPipe's Pose model from CDN, with dynamic options for scalability.
  // Title: InitializePose
  const poseOptions = {
    modelComplexity: 0,
    smoothLandmarks: true,
    enableSegmentation: false
  };
  const pose = new Pose({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
  });
  pose.setOptions(poseOptions);
  pose.onResults(onResults);

  // ===============================
  // Start Camera with Error Handling and Loading State
  // Title: startCamera
  // ===============================
  async function startCamera() {
    showLoading(true);
    try {
      // Stop any previous streams and animation frames
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      // Set constraints, using facingMode for camera selection
      const constraints = {
        audio: false,
        video: {
          facingMode: useFrontCamera ? 'user' : 'environment',
          width: { ideal: 1280 },
          height: { ideal: 720 },
          aspectRatio: 9 / 16,
          frameRate: { ideal: 30 }
        }
      };

      // Request camera access
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      currentStream = stream;
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        video.addEventListener('playing', processVideoFrame, { once: true });
        showLoading(false);
      };
    } catch (err) {
      showLoading(false);
      alert('Unable to access camera. Please check your device settings and permissions.');
      console.error('Camera error:', err);
    }
  }

  // ===============================
  // Loading Indicator Controls
  // Title: showLoading
  // ===============================
  function showLoading(show) {
    if (loadingIndicator) {
      loadingIndicator.style.display = show ? 'block' : 'none';
    }
  }

  // ===============================
  // Frame Processing Loop
  // Title: processVideoFrame
  // ===============================
  async function processVideoFrame() {
    if (video.paused || video.ended) {
      return;
    }
    try {
      await pose.send({ image: video });
    } catch (e) {
      console.error('Pose detection error:', e);
    }
    animationFrameId = requestAnimationFrame(processVideoFrame);
  }

  // ===============================
  // Update Jump Stats and Notify Parent
  // Title: updateStatsDisplay
  // ===============================
  function updateStatsDisplay(airtime, height) {
    // For security, always specify a target origin instead of '*'
    window.parent.postMessage({
      type: 'jump',
      airtime,
      height
    }, parentOrigin);
  }

  // ===============================
  // Jump Logic and Canvas Drawing
  // Title: onResults
  // ===============================
  function onResults(results) {
    // Resize canvas to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (results.poseLandmarks) {
      // Draw pose landmarks and connectors for visualization
      drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#0FF', lineWidth: 3 });
      drawLandmarks(ctx, results.poseLandmarks, { color: '#FF0', radius: 4 });

      // Get ankle landmarks
      const leftAnkle = results.poseLandmarks[27];
      const rightAnkle = results.poseLandmarks[28];

      if (!leftAnkle || !rightAnkle) {
        // If landmarks are not detected, exit early
        ctx.restore();
        return;
      }

      const now = performance.now();
      const canvasX = canvas.width;
      const canvasY = canvas.height;

      // Helper: Check if a foot is within the trampoline region
      function footInTrampoline(pt) {
        const x = pt.x * canvasX;
        const y = pt.y * canvasY;
        const inX = x > 0.1 * canvasX && x < 0.9 * canvasX;
        const inY = y > 0.4 * canvasY && y < 0.9 * canvasY;
        return inX && inY;
      }

      const leftOn = footInTrampoline(leftAnkle);
      const rightOn = footInTrampoline(rightAnkle);
      const isOnTrampoline = leftOn && rightOn;

      // Detect takeoff: both ankles leave trampoline area
      if (!isJumping && !isOnTrampoline) {
        isJumping = true;
        jumpStart = now;
      }

      // Detect landing: both ankles return to trampoline area
      if (isJumping && isOnTrampoline) {
        isJumping = false;
        const airtime = (now - jumpStart) / 1000;

        // Improved jump height formula using physics (height = 0.5 * g * (t/2)^2)
        // Where g = 9.81 m/s^2, t = airtime
        const g = 9.81;
        const height = 0.5 * g * Math.pow(airtime / 2, 2);

        updateStatsDisplay(airtime, height);
      }
    }
    ctx.restore();
  }

  // ===============================
  // Camera Switch Button Handler (with Accessibility)
  // Title: handleSwitchCamera
  // ===============================
  async function handleSwitchCamera() {
    useFrontCamera = !useFrontCamera;
    await startCamera();
    switchCameraBtn.setAttribute('aria-pressed', String(useFrontCamera));
  }
  // Add click and keyboard accessibility
  switchCameraBtn.addEventListener('click', handleSwitchCamera);
  switchCameraBtn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleSwitchCamera();
    }
  });
  switchCameraBtn.setAttribute('aria-label', 'Switch camera');
  switchCameraBtn.setAttribute('tabindex', '0');
  switchCameraBtn.setAttribute('role', 'button');

  // ===============================
  // Cleanup Resources on Unload (Performance)
  // Title: cleanupResources
  // ===============================
  function cleanupResources() {
    if (currentStream) {
      currentStream.getTracks().forEach(track => track.stop());
    }
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
  }
  window.addEventListener('beforeunload', cleanupResources);

  // ===============================
  // Inform User About Camera Access (Security/UX)
  // Title: showCameraAccessNotice
  // ===============================
  function showCameraAccessNotice() {
    // Implement your preferred UI for notifying the user about camera access.
    // For example, display a modal or message before requesting permissions.
    // alert('This application requires access to your camera for jump detection.');
  }

  // ===============================
  // Initialization on Page Load
  // Title: initializeApp
  // ===============================
  (async () => {
    showCameraAccessNotice();
    await startCamera();
  })();

</script>
