<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JumpTek Trampoline Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675039327/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000; /* Black background when video is not playing */
        }

        video, canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensure the video/canvas fits within the container */
            transform: scaleX(-1); /* Flip horizontally for mirror effect */
        }

        #overlay-elements {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to canvas for marking corners */
        }

        #cameraError {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 1.2em;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }

        #trampolineNotice {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            color: #fff;
            font-size: 1.1em;
            text-align: center;
            white-space: nowrap;
            pointer-events: none;
            z-index: 50;
        }

        #controls {
            position: absolute;
            top: 20px;
            display: flex;
            gap: 10px;
            pointer-events: all; /* Re-enable pointer events for buttons */
            z-index: 60;
        }

        #controls button {
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.5em;
            transition: background-color 0.3s, transform 0.1s;
        }
        #controls button:hover:not(:disabled) {
            background-color: #555;
            transform: scale(1.05);
        }
        #controls button:active:not(:disabled) {
            transform: scale(0.95);
        }
        #controls button:disabled {
            background-color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #controls button img {
            filter: invert(1); /* Makes icons white */
            width: 28px;
            height: 28px;
        }

        .debug-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #0f0;
            z-index: 50;
            display: none; /* Hidden by default, shown in debug mode */
        }

        #rawHeightDebugDisplay {
            color: #fff; /* Default color */
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        #rawHeightDebugDisplay.positive {
            color: #0f0; /* Green for positive height */
        }

        #frameRateDisplay {
            color: #fff;
            font-size: 0.9em;
        }

        #debugValuesDisplay {
            font-size: 0.8em;
            color: #aaa;
            margin-top: 5px;
        }

        #zoom-controls {
            position: absolute;
            right: 10px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: all;
            z-index: 60;
        }
        #zoom-controls button {
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 1px solid #555;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.8em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #zoom-controls button:hover:not(:disabled) {
            background-color: rgba(0, 0, 0, 0.8);
        }
        #zoom-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Settings Popover */
        #settingsPopover {
            position: absolute;
            top: 70px;
            background-color: rgba(34, 34, 34, 0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            z-index: 70;
            right: 20px;
            transform: scale(0.9);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
            transform-origin: top right;
        }

        #settingsPopover.open {
            transform: scale(1);
            opacity: 1;
            pointer-events: all;
        }

        #settingsPopover h3 {
            margin-top: 0;
            color: #fff;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        #settingsPopover label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
            font-size: 0.95em;
        }

        #settingsPopover input[type="number"],
        #settingsPopover input[type="checkbox"] {
            margin-left: 5px;
            background-color: #444;
            border: 1px solid #666;
            color: #fff;
            padding: 5px;
            border-radius: 3px;
            width: calc(100% - 10px);
            box-sizing: border-box;
            margin-top: 3px;
        }
        #settingsPopover input[type="checkbox"] {
            width: auto;
        }

        #settingsPopover .setting-group {
            margin-bottom: 15px;
        }

        #settingsPopover button {
            background-color: #007bff;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        #settingsPopover button:hover {
            background-color: #0056b3;
        }

        #settingsPopover .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #bbb;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
        }
        #settingsPopover .close-btn:hover {
            color: #fff;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>

        <div id="overlay-elements">
            <p id="cameraError" style="display: none;">Camera access denied or no camera found. Please ensure you grant camera permissions and try again.</p>
            <p id="trampolineNotice">Initializing Camera...</p>

            <div id="controls">
                <button id="cameraSwitchBtn" aria-label="Switch Camera" tabindex="0" role="button">
                    <img src="https://icon-library.com/images/switch-camera-icon/switch-camera-icon-7.jpg" alt="Switch Camera" />
                </button>
                <button id="clearCornersBtn" aria-label="Clear marked corners" tabindex="0" role="button" style="display: none;">
                    <img src="https://icon-library.com/images/clear-icon-png/clear-icon-png-3.jpg" alt="Clear Corners" />
                </button>
                <button id="calibrateBtn" aria-label="Calibrate baseline" tabindex="0" role="button" style="display: none;">
                    <img src="https://icon-library.com/images/wrench-icon-png/wrench-icon-png-11.jpg" alt="Calibrate" />
                </button>
                <button id="settingsBtn" aria-label="Settings" tabindex="0" role="button">
                    <img src="https://icon-library.com/images/settings-icon-png/settings-icon-png-20.jpg" alt="Settings" />
                </button>
            </div>

            <div id="zoom-controls">
                <button id="zoomInBtn" aria-label="Zoom In">+</button>
                <button id="zoomOutBtn" aria-label="Zoom Out">-</button>
            </div>

            <div id="settingsPopover">
                <button class="close-btn" id="closeSettingsBtn">&times;</button>
                <h3>Settings</h3>
                <div class="setting-group">
                    <label for="cameraDistance">Camera Distance (m):</label>
                    <input type="number" id="cameraDistance" value="2.0" step="0.1" min="0.1">
                </div>
                <div class="setting-group">
                    <label for="cameraHeight">Camera Height (m):</label>
                    <input type="number" id="cameraHeight" value="1.0" step="0.1" min="0.1">
                </div>
                <div class="setting-group">
                    <label for="depthScaleFactor">Depth Scale Factor:</label>
                    <input type="number" id="depthScaleFactor" value="5.0" step="0.1" min="0.1">
                </div>
                <div class="setting-group">
                    <label for="debugModeCheckbox">Debug Mode:</label>
                    <input type="checkbox" id="debugModeCheckbox">
                </div>
                <button id="saveSettingsBtn">Save</button>
            </div>

            <div id="rawHeightDebugDisplay" class="debug-display">
                Raw Z-Delta: N/A
            </div>
            <div id="frameRateDisplay" class="debug-display" style="top: 60px;">FPS: N/A</div>
            <div id="debugValuesDisplay" class="debug-display" style="top: 100px;"></div>
        </div>
    </div>

    <script>
    // Constants for calibration phases
    const CALIBRATION_PHASE_MARK_CORNERS = 'mark_corners';
    const CALIBRATION_PHASE_STAND_STILL = 'stand_still';
    const CALIBRATION_PHASE_JUMP_CALIBRATION = 'jump_calibration';
    const CALIBRATION_PHASE_COMPLETE = 'complete';

    // Jump state machine constants
    const JUMP_STATE_ON_TRAMPOLINE = 'on_trampoline';
    const JUMP_STATE_AIRBORNE = 'airborne';
    const JUMP_STATE_DESCENDING = 'descending';

    // HTML Elements
    const videoElement = document.getElementById('videoElement');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const trampolineNotice = document.getElementById('trampolineNotice');
    const cameraErrorDiv = document.getElementById('cameraError');
    const calibrateBtn = document.getElementById('calibrateBtn');
    const clearCornersBtn = document.getElementById('clearCornersBtn');
    const switchCameraBtn = document.getElementById('cameraSwitchBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const debugModeCheckbox = document.getElementById('debugModeCheckbox');
    const rawHeightDebugDisplay = document.getElementById('rawHeightDebugDisplay');
    const frameRateDisplay = document.getElementById('frameRateDisplay');
    const debugValuesDisplay = document.getElementById('debugValuesDisplay');

    let pose;
    let currentStream = null;
    let videoTrack = null;
    let zoomCapabilities = null;
    let useFrontCamera = false;
    let lastPoseResults = null;

    // Calibration state variables
    let currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
    let trampolineCorners = []; // Stores {x, y} for 4 corners
    let trampolinePolygon = null; // Stores the polygon object for point-in-polygon check
    let calibrationReady = false; // True when stand-still calibration is complete
    let baselineZ = null; // Average Z-value from stand-still calibration
    let calibrationZValues = []; // Stores Z-values during stand-still calibration
    let calibrationJumpsData = []; // Stores {h3d, hflight} for Z-scale calibration

    // Jump tracking variables
    let jumpState = JUMP_STATE_ON_TRAMPOLINE;
    let takeOffTime = 0;
    let highestPointZ = -Infinity; // Stores the highest Z (closest to camera) reached during a jump
    let flightTime = 0;

    // Smoothing variables
    let currentZSmoothed = null;
    let verticalVelocitySmoothed = null;

    // FPS calculation
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let lastFpsUpdateTime = 0;

    // Calibration configuration
    const CALIBRATION_DURATION_MS = 5000; // 5 seconds for stand-still calibration
    const CALIBRATION_INTERVAL_MS = 100; // Sample every 100ms
    const REQUIRED_CALIBRATION_JUMPS = 5; // Number of jumps needed for Z-scale calibration

    // CONFIGURABLE PARAMETERS (default values if not in local storage)
    let cameraDistanceMeters = parseFloat(localStorage.getItem('jt_cameraDistance')) || 2.0;
    let cameraHeightMeters   = parseFloat(localStorage.getItem('jt_cameraHeight')) || 1.0;
    let depthScaleFactor = parseFloat(localStorage.getItem('jt_depthScaleFactor')) || 5.0; // Starting value, will be tuned

    // --- Smoothing Parameters ---
    const ALPHA_Z_SMOOTHING = 0.4; // Higher alpha means less smoothing (0-1)
    const ALPHA_VELOCITY_SMOOTHING = 0.3; // Higher alpha means less smoothing (0-1)

    // --- Jump Detection Thresholds (tweaked for robustness) ---
    const MIN_JUMP_DISPLAY_THRESHOLD = 0.05; // Minimum height to display as a jump
    const GRAVITY = 9.81; // m/s^2

    // Thresholds for jump detection (in meters)
    const JUMP_OFF_TRAMPOLINE_THRESHOLD_METERS = 0.05; // How far above baseline to count as leaving trampoline
    const LANDING_ON_TRAMPOLINE_THRESHOLD_METERS = 0.03; // How close to baseline to count as landing

    // Velocity thresholds for jump state changes (m/s) - more robust
    const TAKEOFF_VELOCITY_THRESHOLD = 0.1; // Min positive velocity to confirm takeoff
    const PEAK_VELOCITY_THRESHOLD = -0.05; // Negative velocity indicating descent past peak
    const LANDING_VELOCITY_THRESHOLD = -0.2; // Max negative velocity at landing (can be slightly negative due to impact)

    let debugMode = (localStorage.getItem('jt_debugMode') === 'true');


    // --------- MEDIA PIPE SETUP ---------
    async function initializePose() {
        pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675039327/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1, // 0 (fastest, less accurate), 1 (balanced), 2 (slowest, most accurate)
            smoothLandmarks: true,
            enableSegmentation: false, // Not needed for this app, save performance
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);
    }

    async function startCamera() {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }

        cameraErrorDiv.style.display = 'none';
        trampolineNotice.textContent = "Initializing Camera...";
        trampolineNotice.style.color = '#fff';

        try {
            const constraints = {
                video: {
                    facingMode: useFrontCamera ? 'user' : 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                }
            };
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            videoElement.srcObject = currentStream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                videoTrack = currentStream.getVideoTracks()[0];
                updateZoomCapabilities();
                trampolineNotice.textContent = "Camera Ready. Tap the four corners of the trampoline to mark its boundaries.";
                trampolineNotice.style.color = '#fff';
            };
        } catch (err) {
            console.error("Error accessing camera:", err);
            cameraErrorDiv.style.display = 'block';
            trampolineNotice.style.display = 'none';
        }
    }

    async function updateZoomCapabilities() {
        if (videoTrack) {
            const capabilities = videoTrack.getCapabilities();
            if (capabilities.zoom) {
                zoomCapabilities = capabilities.zoom;
                zoomInBtn.disabled = false;
                zoomOutBtn.disabled = false;
            } else {
                zoomCapabilities = null;
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
            }
        }
    }

    function onResults(results) {
        lastPoseResults = results; // Store results for use in setInterval and other functions
        drawLoop(results);
    }

    async function detectionLoop() {
        if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
            await pose.send({ image: videoElement });
        }
        requestAnimationFrame(detectionLoop);
    }

    function drawLoop(results) {
        const currentTime = performance.now();
        frameCount++;
        if (currentTime - lastFpsUpdateTime >= 1000) {
            const fps = (frameCount / ((currentTime - lastFpsUpdateTime) / 1000)).toFixed(1);
            if (debugMode) {
                frameRateDisplay.textContent = `FPS: ${fps}`;
            }
            frameCount = 0;
            lastFpsUpdateTime = currentTime;
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        // Draw pose landmarks if available
        if (results.poseLandmarks) {
            if (debugMode) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FFFF00', lineWidth: 2, radius: 6 });
            }
        }

        // Draw trampoline corners and polygon
        if (trampolineCorners.length > 0) {
            canvasCtx.strokeStyle = 'yellow';
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();
            canvasCtx.moveTo(trampolineCorners[0].x, trampolineCorners[0].y);
            for (let i = 1; i < trampolineCorners.length; i++) {
                canvasCtx.lineTo(trampolineCorners[i].x, trampolineCorners[i].y);
            }
            if (trampolineCorners.length === 4) {
                canvasCtx.closePath();
            }
            canvasCtx.stroke();

            // Draw circles at corners
            for (const corner of trampolineCorners) {
                canvasCtx.beginPath();
                canvasCtx.arc(corner.x, corner.y, 8, 0, 2 * Math.PI);
                canvasCtx.fillStyle = 'yellow';
                canvasCtx.fill();
            }
        }

        canvasCtx.restore();

        // Update UI elements based on calibration phase
        switch (currentCalibrationPhase) {
            case CALIBRATION_PHASE_MARK_CORNERS:
                calibrateBtn.style.display = "none";
                clearCornersBtn.style.display = "block";
                trampolineNotice.textContent = `Tap the four corners of the trampoline to mark its boundaries. (${trampolineCorners.length}/4)`;
                break;
            case CALIBRATION_PHASE_STAND_STILL:
                calibrateBtn.style.display = "block";
                clearCornersBtn.style.display = "block";

                // Enable/Disable calibrate button based on pose detection
                const canEnableCalibrate = (lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0);
                calibrateBtn.disabled = !canEnableCalibrate;

                if (!canEnableCalibrate) {
                    trampolineNotice.textContent = "Waiting for pose data... Please ensure your body is visible and still. ";
                    trampolineNotice.style.color = '#ff0';
                } else if (!trampolineNotice.textContent.includes("Calibrating...")) { // Don't overwrite calibration message
                    trampolineNotice.textContent = "Trampoline area set! Stand still on the trampoline and press Calibrate.";
                    trampolineNotice.style.color = '#fff';
                }
                break;
            case CALIBRATION_PHASE_JUMP_CALIBRATION:
                calibrateBtn.style.display = "none"; // Hide during jump calibration
                clearCornersBtn.style.display = "block";
                // Trampoline notice updated by jump calibration logic
                break;
            case CALIBRATION_PHASE_COMPLETE:
                calibrateBtn.style.display = "block"; // Re-show after completion to allow recalibration
                clearCornersBtn.style.display = "block";
                if (!trampolineNotice.textContent.includes("Jump height tracking active")) { // Don't overwrite active message
                    trampolineNotice.textContent = "Calibration Complete! Jump height tracking active.";
                    trampolineNotice.style.color = '#0f0';
                }
                // Button remains enabled so user can re-calibrate anytime
                calibrateBtn.disabled = false;
                break;
        }

        // Console logs for debugging button state
        if (debugMode) {
            console.log(`[DRAW] Current Cal Phase: ${currentCalibrationPhase}`);
            console.log(`[DRAW] Trampoline Polygon: ${trampolinePolygon ? 'Set' : 'Not Set'}`);
            console.log(`[DRAW] Last Pose Results: ${lastPoseResults && lastPoseResults.poseLandmarks ? 'Available' : 'Not Available'}`);
            console.log(`[DRAW] Calibrate Btn Display: ${calibrateBtn.style.display}, Disabled: ${calibrateBtn.disabled} (Can Enable: ${canEnableCalibrate})`);
            console.log(`[NOTICE] ${trampolineNotice.textContent}`);
        }
    }


    // --------- COORDINATE TRANSFORMATION FUNCTIONS ---------
    // These functions convert pixel coordinates and Z-depth to real-world meters
    // based on estimated camera parameters.
    // They are simplified perspective transformations.
    function pixelToWorld(pixelX, pixelY, pixelZ) {
        // Normalize pixel coordinates to -1 to 1 range (where 0,0 is center of image)
        const normalizedX = (pixelX / canvasElement.width) * 2 - 1;
        const normalizedY = (pixelY / canvasElement.height) * 2 - 1;

        // Apply a depth scaling factor. MediaPipe's Z is relative, not absolute meters.
        // It's also relative to the center of the hips, not the camera.
        // A higher depthScaleFactor makes objects appear further away for the same pixelZ.
        const scaledZ = pixelZ * depthScaleFactor;

        // These are simplified calculations assuming a frontal camera view
        // and estimating physical size based on visual angle and camera parameters.
        // This is the core part that needs careful calibration.

        // Estimate X and Y in meters, relative to the camera's assumed position
        // This assumes a virtual focal length. `cameraDistanceMeters` affects this.
        const worldX = normalizedX * cameraDistanceMeters * Math.abs(scaledZ); // Farther objects appear wider
        const worldY = normalizedY * cameraDistanceMeters * Math.abs(scaledZ) * (canvasElement.videoHeight / canvasElement.videoWidth); // Account for aspect ratio

        // Z-axis is typically distance from camera. MediaPipe's Z is positive outwards.
        // We invert it here so positive Z means further from camera, 0 is at some reference plane.
        // And adjust by cameraDistanceMeters to place the "0" plane correctly.
        const worldZ = -scaledZ + cameraDistanceMeters;

        return [worldX, worldY, worldZ];
    }

    // Function to check if a point is inside a polygon (trampoline area)
    // Ray-casting algorithm
    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3) return false;
        let x = point.x, y = point.y;
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            let xi = polygon[i].x, yi = polygon[i].y;
            let xj = polygon[j].x, yj = polygon[j].y;

            let intersect = ((yi > y) != (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }


    // --------- EVENT LISTENERS & UI LOGIC ---------

    // Canvas click listener for marking corners
    canvasElement.addEventListener('click', (event) => {
        if (currentCalibrationPhase === CALIBRATION_PHASE_MARK_CORNERS) {
            const rect = canvasElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (trampolineCorners.length < 4) {
                trampolineCorners.push({ x, y });
                if (trampolineCorners.length === 4) {
                    trampolinePolygon = trampolineCorners; // Set the polygon
                    currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL;
                    trampolineNotice.textContent = "Trampoline area set! Stand still on the trampoline and press Calibrate.";
                    trampolineNotice.style.color = '#fff';
                    clearCornersBtn.style.display = "block"; // Ensure clear button is visible
                    calibrateBtn.style.display = "block"; // Show calibrate button
                    console.log("[CALIBRATION] Trampoline corners marked. Ready for stand-still calibration.");
                }
            }
        }
    });

    clearCornersBtn.addEventListener('click', () => {
        trampolineCorners = [];
        trampolinePolygon = null;
        currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
        calibrationReady = false;
        baselineZ = null;
        trampolineNotice.textContent = "Cleared. Tap the four corners of the trampoline to mark its boundaries.";
        trampolineNotice.style.color = '#fff';
        calibrateBtn.style.display = "none"; // Hide calibrate button again
        console.log("[CALIBRATION] Trampoline corners cleared.");
    });


    calibrateBtn.addEventListener('click', async function() {
        // Added log for clarity to see if click listener is firing and in which phase
        console.log(`[CALIBRATE_BTN_CLICK] Clicked! Current Phase: ${currentCalibrationPhase}`);

        if (currentCalibrationPhase === CALIBRATION_PHASE_STAND_STILL) {
            if (!trampolinePolygon) {
                trampolineNotice.style.color = '#f00';
                trampolineNotice.textContent = "Error: Please mark the 4 corners of the trampoline first.";
                console.error("[CALIBRATE_BTN_CLICK] Calibration attempted without trampoline polygon.");
                return;
            }

            // Temporarily disable the calibrate button to prevent multiple clicks
            // and indicate that calibration is in progress.
            calibrateBtn.disabled = true;
            calibrationZValues = []; // Clear any previous calibration data

            let calibrationSamples = 0;
            const maxCalibrationSamples = CALIBRATION_DURATION_MS / CALIBRATION_INTERVAL_MS;

            const checkPoseAndStartCalibration = () => {
                // Initial check for pose data before starting the main loop
                if (!lastPoseResults || !lastPoseResults.poseLandmarks || lastPoseResults.poseLandmarks.length === 0) {
                    trampolineNotice.style.color = '#f00';
                    trampolineNotice.textContent = "Error: No pose detected. Please ensure your body is fully visible and try again.";
                    console.error("[CALIBRATE_BTN_CLICK] Calibration attempted without valid pose landmarks.");
                    calibrateBtn.disabled = false; // Re-enable button on failure
                    return; // Exit if no pose at all
                }

                trampolineNotice.textContent = `CALIBRATING... Please stand still. ${((CALIBRATION_DURATION_MS - (calibrationSamples * CALIBRATION_INTERVAL_MS)) / 1000).toFixed(1)}s remaining.`;
                trampolineNotice.style.color = '#fff';

                const calibrationLoop = setInterval(() => {
                    calibrationSamples++;
                    const progress = Math.min(100, (calibrationSamples / maxCalibrationSamples) * 100);
                    trampolineNotice.textContent = `CALIBRATING... Please stand still. ${((CALIBRATION_DURATION_MS - (calibrationSamples * CALIBRATION_INTERVAL_MS)) / 1000).toFixed(1)}s remaining.`;
                    trampolineNotice.style.color = '#fff'; // Keep white during normal progress

                    if (lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0) {
                        const lowestLandmark = getLowestBodyLandmark(lastPoseResults.poseLandmarks);

                        if (lowestLandmark) {
                            const lx = lowestLandmark.x * canvasElement.width;
                            const ly = lowestLandmark.y * canvasElement.height;

                            // Check if the lowest landmark is within the marked trampoline polygon
                            if (isPointInPolygon({ x: lx, y: ly }, trampolinePolygon)) {
                                const worldPt = pixelToWorld(lx, ly, lowestLandmark.z);
                                calibrationZValues.push(worldPt[2]);
                                if (debugMode) {
                                    console.log(`[CALIBRATION_LOOP] Sample ${calibrationZValues.length}: Z = ${worldPt[2].toFixed(3)}m`);
                                }
                            } else {
                                trampolineNotice.textContent = `CALIBRATING... (Outside Trampoline) Please stand inside the marked area. ${((CALIBRATION_DURATION_MS - (calibrationSamples * CALIBRATION_INTERVAL_MS)) / 1000).toFixed(1)}s remaining.`;
                                trampolineNotice.style.color = '#ff0'; // Change to warning color
                                console.warn("[CALIBRATION_LOOP] Lowest landmark outside trampoline area.");
                            }
                        } else {
                            trampolineNotice.textContent = `CALIBRATING... (No Body Landmark) Please ensure your lower body is visible. ${((CALIBRATION_DURATION_MS - (calibrationSamples * CALIBRATION_INTERVAL_MS)) / 1000).toFixed(1)}s remaining.`;
                            trampolineNotice.style.color = '#ff0'; // Change to warning color
                            console.warn("[CALIBRATION_LOOP] No suitable low landmark found for this sample.");
                        }
                    } else {
                        trampolineNotice.textContent = `CALIBRATING... (No Pose Data) Please ensure your body is visible. ${((CALIBRATION_DURATION_MS - (calibrationSamples * CALIBRATION_INTERVAL_MS)) / 1000).toFixed(1)}s remaining.`;
                        trampolineNotice.style.color = '#ff0'; // Change to warning color
                        console.warn("[CALIBRATION_LOOP] No pose data for this sample.");
                    }

                    if (calibrationSamples >= maxCalibrationSamples) {
                        clearInterval(calibrationLoop);
                        
                        if (calibrationZValues.length > 0) {
                            // Filter outliers from calibrationZValues using IQR method
                            const sortedZ = [...calibrationZValues].sort((a,b) => a - b);
                            const q1 = sortedZ[Math.floor(sortedZ.length * 0.25)];
                            const q3 = sortedZ[Math.ceil(sortedZ.length * 0.75) -1];
                            const iqr = q3 - q1;
                            const lowerBound = q1 - 1.5 * iqr;
                            const upperBound = q3 + 1.5 * iqr;

                            const filteredZValues = calibrationZValues.filter(z => z >= lowerBound && z <= upperBound);
                            
                            if (filteredZValues.length > 0) {
                                const sumZ = filteredZValues.reduce((a, b) => a + b, 0);
                                baselineZ = sumZ / filteredZValues.length;
                                console.log(`[CALIBRATION_COMPLETE] Calibrated trampoline Z baseline (averaged, filtered): ${baselineZ.toFixed(3)}m`);
                                
                                currentCalibrationPhase = CALIBRATION_PHASE_JUMP_CALIBRATION;
                                calibrationJumpsData = []; // Clear previous jump data
                                trampolineNotice.style.color = '#0f0';
                                trampolineNotice.textContent = `Baseline set! Now perform ${REQUIRED_CALIBRATION_JUMPS} jumps for Z-scale calibration.`;
                                calibrateBtn.style.display = "none"; // Hide calibrate button during jump calibration
                                jumpState = JUMP_STATE_ON_TRAMPOLINE; // Reset jump state for new phase
                                currentZSmoothed = null; // Reset smoothing for new phase
                                verticalVelocitySmoothed = null;
                            } else {
                                trampolineNotice.style.color = '#f00';
                                trampolineNotice.textContent = "Calibration failed: No valid baseline data after filtering. Try again from a stable position.";
                                baselineZ = null;
                                currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL;
                                calibrateBtn.disabled = false;
                                console.error("[CALIBRATION_COMPLETE] No valid baseline data after filtering.");
                            }
                        } else {
                            trampolineNotice.style.color = '#f00';
                            trampolineNotice.textContent = "Calibration failed: No valid baseline data collected. Make sure your ankles/hips are visible and still.";
                            baselineZ = null;
                            currentCalibrationPhase = CALIBRATION_PHASE_STAND_STILL; // Go back to stand still phase
                            calibrateBtn.disabled = false; // Re-enable to retry
                            console.error("[CALIBRATION_COMPLETE] No valid baseline data collected at all.");
                        }
                    }
                }, CALIBRATION_INTERVAL_MS);
            };

            checkPoseAndStartCalibration(); // Initiate the robust pose check

        } else {
            console.warn(`[CALIBRATE_BTN_CLICK] Button clicked in incorrect phase: ${currentCalibrationPhase}`);
        }
    });

    // --------- SETTINGS POPOVER LOGIC ---------
    const settingsBtn  = document.getElementById('settingsBtn');
    const settingsPopover = document.getElementById('settingsPopover');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const saveSettingsBtn  = document.getElementById('saveSettingsBtn');

    settingsBtn.addEventListener('click', e => {
      e.stopPropagation();
      settingsPopover.classList.toggle('open');
    });
    closeSettingsBtn.addEventListener('click', () => settingsPopover.classList.remove('open'));
    document.addEventListener('mousedown', e => {
      if (settingsPopover.classList.contains('open') &&
          !settingsPopover.contains(e.target) &&
          e.target !== settingsBtn) {
        settingsPopover.classList.remove('open');
      }
    });

    // --------- SAVE/LOAD SETTINGS ---------
    const cameraDistanceInput = document.getElementById('cameraDistance');
    const cameraHeightInput   = document.getElementById('cameraHeight');
    const depthScaleFactorInput = document.getElementById('depthScaleFactor');

    function applyDebugMode() {
        if (debugMode) {
            rawHeightDebugDisplay.style.display = 'block';
            frameRateDisplay.style.display = 'block'; // Show FPS in debug mode
            debugValuesDisplay.style.display = 'block';
        } else {
            rawHeightDebugDisplay.style.display = 'none';
            frameRateDisplay.style.display = 'none';
            debugValuesDisplay.style.display = 'none';
        }
    }

    function saveSettingsToStorage() {
      localStorage.setItem('jt_cameraDistance', cameraDistanceInput.value);
      localStorage.setItem('jt_cameraHeight',    cameraHeightInput.value);
      localStorage.setItem('jt_depthScaleFactor', depthScaleFactorInput.value);
      localStorage.setItem('jt_debugMode', debugModeCheckbox.checked ? 'true' : 'false');
      console.log("[SETTINGS] Settings saved to local storage.");
    }
    function loadSettingsFromStorage() {
      ['jt_cameraDistance','jt_cameraHeight', 'jt_depthScaleFactor'].forEach(k => {
        const v = localStorage.getItem(k);
        if (v !== null) {
          document.getElementById({
            'jt_cameraDistance':'cameraDistance',
            'jt_cameraHeight':'cameraHeight',
            'jt_depthScaleFactor':'depthScaleFactor'
          }[k]).value = v;
        }
      });

      const loadedDebugMode = localStorage.getItem('jt_debugMode');
      debugMode = (loadedDebugMode === 'true');
      debugModeCheckbox.checked = debugMode;
      applyDebugMode();
      console.log("[SETTINGS] Settings loaded from local storage.");

      ['cameraDistance','cameraHeight', 'depthScaleFactor'].forEach(id =>
        document.getElementById(id).dispatchEvent(new Event('input'))
      );
    }

    saveSettingsBtn.addEventListener('click', () => {
      saveSettingsToStorage();
      debugMode = debugModeCheckbox.checked;
      applyDebugMode();
      // If settings are changed, it implies current calibration might be invalid
      // Reset to mark corners phase to force full recalibration
      currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
      calibrationReady = false;
      baselineZ = null;
      trampolinePolygon = null;
      trampolineCorners = [];
      trampolineNotice.textContent = "Settings changed. Please re-mark trampoline corners and re-calibrate.";
      calibrateBtn.style.display = "none"; // Hide until corners are marked
      saveSettingsBtn.textContent = 'Saved!';
      setTimeout(() => saveSettingsBtn.textContent = 'Save', 1200);
      // Reset smoothing when settings change
      currentZSmoothed = null;
      verticalVelocitySmoothed = null;
      console.log("[SETTINGS] Settings saved. Calibration reset required.");
    });
    window.addEventListener('DOMContentLoaded', loadSettingsFromStorage);

    cameraDistanceInput.addEventListener('input', () => {
      cameraDistanceMeters = parseFloat(cameraDistanceInput.value) || 2.0;
      console.log(`[INPUT] Camera Distance: ${cameraDistanceMeters}m`);
    });
    cameraHeightInput.addEventListener('input', () => {
      cameraHeightMeters = parseFloat(cameraHeightInput.value) || 1.0;
      console.log(`[INPUT] Camera Height: ${cameraHeightMeters}m`);
    });
    depthScaleFactorInput.addEventListener('input', () => {
      depthScaleFactor = parseFloat(depthScaleFactorInput.value) || 5.0;
      console.log(`[INPUT] Depth Scale Factor: ${depthScaleFactor}`);
    });

    // --------- CAMERA SWITCH & CLEANUP ---------
    switchCameraBtn.addEventListener('click', async () => {
      useFrontCamera = !useFrontCamera;
      await startCamera();
      // Reset full calibration on camera switch
      currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
      calibrationReady = false;
      baselineZ = null;
      trampolineNotice.textContent = "Camera switched. Please re-mark trampoline corners and re-calibrate.";
      calibrateBtn.style.display = "none";
      trampolineCorners = [];
      trampolinePolygon = null;
      jumpState = JUMP_STATE_ON_TRAMPOLINE;
      highestPointZ = -Infinity;
      flightTime = 0;
      // Reset smoothing history
      currentZSmoothed = null;
      verticalVelocitySmoothed = null;
      console.log("[CAMERA_SWITCH] Camera switched. Calibration reset required.");
    });
    window.addEventListener('beforeunload', () => {
      if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    });

    // --------- ZOOM CONTROLS ---------
    const resetCalibrationForZoom = () => {
        // Reset full calibration on zoom change
        currentCalibrationPhase = CALIBRATION_PHASE_MARK_CORNERS;
        calibrationReady = false;
        baselineZ = null;
        trampolineNotice.textContent = "Zoom changed. Please re-mark trampoline corners and re-calibrate.";
        calibrateBtn.style.display = "none";
        trampolineCorners = [];
        trampolinePolygon = null;
        jumpState = JUMP_STATE_ON_TRAMPOLINE;
        highestPointZ = -Infinity;
        flightTime = 0;
        // Reset smoothing history
        currentZSmoothed = null;
        verticalVelocitySmoothed = null;
        console.log("[ZOOM] Zoom changed. Calibration reset required.");
    };

    zoomInBtn.addEventListener('click', async () => {
        if (!videoTrack || !zoomCapabilities) return;
        const currentZoom = videoTrack.getSettings().zoom || zoomCapabilities.min;
        const newZoom = Math.min(zoomCapabilities.max, currentZoom + zoomCapabilities.step);
        try {
            await videoTrack.applyConstraints({ advanced: [{ zoom: newZoom }] });
            resetCalibrationForZoom();
        } catch (e) {
            console.error("Failed to set zoom:", e);
        }
    });

    zoomOutBtn.addEventListener('click', async () => {
        if (!videoTrack || !zoomCapabilities) return;
        const currentZoom = videoTrack.getSettings().zoom || zoomCapabilities.min;
        const newZoom = Math.max(zoomCapabilities.min, currentZoom - zoomCapabilities.step);
        try {
            await videoTrack.applyConstraints({ advanced: [{ zoom: newZoom }] });
            resetCalibrationForZoom();
        } catch (e) {
            console.error("Failed to set zoom:", e);
        }
    });

    // Initial state for zoom buttons
    zoomInBtn.disabled = true;
    zoomOutBtn.disabled = true;

    // Helper to get the lowest landmark (on screen Y) for tracking
    // Prioritizes ankles, then knees, then hips for robustness
    function getLowestBodyLandmark(landmarks) {
        // Define relevant lower body landmarks by their indices
        const relevantLandmarkIndices = [
            27, 28, // Left and Right Ankle
            25, 26, // Left and Right Knee
            23, 24  // Left and Right Hip
        ];
        
        let lowestLandmark = null;
        let lowestY = -Infinity; // Canvas Y-coordinate (higher is lower on screen)

        // SUGGESTED FIX: Slightly lower the confidence threshold for initial testing
        const MIN_LANDMARK_CONFIDENCE = 0.5; // Adjusted from 0.6 for better detection in challenging environments

        // Find the lowest point among all relevant landmarks that have a high enough confidence score
        for (const index of relevantLandmarkIndices) {
            const landmark = landmarks[index];
            if (landmark && landmark.score > MIN_LANDMARK_CONFIDENCE) { // Use adjusted confidence threshold
                // If it's the first confident landmark or lower than current lowest
                if (!lowestLandmark || landmark.y > lowestY) {
                    lowestY = landmark.y;
                    lowestLandmark = landmark;
                }
            }
        }

        // If no reliable lower body landmark is found, try other body parts like shoulders or nose,
        // though this is less ideal for jump tracking
        if (!lowestLandmark) {
            // Fallback to a central, reliable landmark like the nose or shoulders, if needed
            // This is a last resort to keep tracking something, but accuracy for Z might suffer.
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];

            // Use the same adjusted MIN_LANDMARK_CONFIDENCE for fallbacks
            if (nose && nose.score > MIN_LANDMARK_CONFIDENCE) {
                console.warn("[getLowestBodyLandmark] Falling back to Nose landmark (index 0).");
                return nose;
            }
            if (leftShoulder && leftShoulder.score > MIN_LANDMARK_CONFIDENCE) {
                console.warn("[getLowestBodyLandmark] Falling back to Left Shoulder landmark (index 11).");
                return leftShoulder;
            }
            if (rightShoulder && rightShoulder.score > MIN_LANDMARK_CONFIDENCE) {
                console.warn("[getLowestBodyLandmark] Falling back to Right Shoulder landmark (index 12).");
                return rightShoulder;
            }
        }
        
        if (!lowestLandmark) {
            console.warn("[getLowestBodyLandmark] No reliable landmarks found for tracking.");
        }

        return lowestLandmark;
    }

    // --------- COMPUTE & SEND JUMP HEIGHT ---------
    let lastZPosRaw = null; // Store raw Z for velocity calculation
    let lastTimeRaw = null; // Store time for velocity calculation

    function computeAndSendJump(landmarks) {
      const currentTime = performance.now();

      // Update FPS display if debug mode is active
      if (debugMode) {
          if (!lastFpsUpdateTime) lastFpsUpdateTime = currentTime; // Initialize
          // FPS is updated in drawLoop, no need to duplicate here
          // Update debug values display
          debugValuesDisplay.innerHTML = `Baseline Z: ${baselineZ !== null ? baselineZ.toFixed(3) : 'N/A'}<br>`;
          debugValuesDisplay.innerHTML += `Jump State: ${jumpState}<br>`;
          debugValuesDisplay.innerHTML += `Cal Phase: ${currentCalibrationPhase}<br>`;
      }

      // Exit early if not in a tracking or jump calibration phase, or if not calibrated
      if ((currentCalibrationPhase !== CALIBRATION_PHASE_COMPLETE && currentCalibrationPhase !== CALIBRATION_PHASE_JUMP_CALIBRATION) || baselineZ === null) {
        if (debugMode) {
            rawHeightDebugDisplay.textContent = 'Raw Z-Delta: N/A';
            rawHeightDebugDisplay.classList.remove('positive');
            debugValuesDisplay.innerHTML += 'Not fully calibrated for tracking.';
        }
        sendJumpHeight(0, false); // Send 0 and not calibrated status
        return;
      }

      const lowestLandmark = getLowestBodyLandmark(landmarks);

      if (!lowestLandmark) {
          if (debugMode) {
              rawHeightDebugDisplay.textContent = 'Raw Z-Delta: No Landmrk';
              rawHeightDebugDisplay.classList.remove('positive');
              debugValuesDisplay.innerHTML += 'No suitable low landmark found.';
          }
          sendJumpHeight(0, true); // Still calibrated, but no pose data this frame
          return;
      }

      const lx = lowestLandmark.x * canvasElement.width;
      const ly = lowestLandmark.y * canvasElement.height;  

      const worldPt = pixelToWorld(lx, ly, lowestLandmark.z);
      const currentZRaw = worldPt[2]; // Raw Z position

      // --- Calculate Raw Vertical Velocity ---
      let verticalVelocityRaw = 0;
      if (lastZPosRaw !== null && lastTimeRaw !== null) {
          const deltaTime = (currentTime - lastTimeRaw) / 1000;
          if (deltaTime > 0) {
              verticalVelocityRaw = (currentZRaw - lastZPosRaw) / deltaTime;
          }
      }
      lastZPosRaw = currentZRaw;
      lastTimeRaw = currentTime;


      // --- Exponential Smoothing ---
      if (currentZSmoothed === null) {
          currentZSmoothed = currentZRaw;
          verticalVelocitySmoothed = verticalVelocityRaw;
      } else {
          currentZSmoothed = ALPHA_Z_SMOOTHING * currentZRaw + (1 - ALPHA_Z_SMOOTHING) * currentZSmoothed;
          verticalVelocitySmoothed = ALPHA_VELOCITY_SMOOTHING * verticalVelocityRaw + (1 - ALPHA_VELOCITY_SMOOTHING) * verticalVelocitySmoothed;
      }

      // Update highest point reached *during* airborne phase using smoothed Z
      if (jumpState === JUMP_STATE_AIRBORNE && currentZSmoothed > highestPointZ) {
          highestPointZ = currentZSmoothed;
      }
      
      if (debugMode) {
          rawHeightDebugDisplay.textContent = `Current Z: ${currentZSmoothed.toFixed(3)}m`;
          debugValuesDisplay.innerHTML += `Smoothed Z: ${currentZSmoothed.toFixed(3)}m<br>`;
          debugValuesDisplay.innerHTML += `Smoothed Vel: ${verticalVelocitySmoothed.toFixed(2)} m/s<br>`;
          debugValuesDisplay.innerHTML += `Raw Z: ${currentZRaw.toFixed(3)}m<br>`;
          debugValuesDisplay.innerHTML += `Raw Vel: ${verticalVelocityRaw.toFixed(2)} m/s<br>`;
          if (currentZSmoothed > baselineZ + 0.05) {
              rawHeightDebugDisplay.classList.add('positive');
          } else {
              rawHeightDebugDisplay.classList.remove('positive');
          }
      }

      // --- Jump State Machine with Hysteresis and Smoothed Values ---
      switch (jumpState) {
          case JUMP_STATE_ON_TRAMPOLINE:
              // Condition to go Airborne: Z is above baseline AND vertical velocity is positive
              if (currentZSmoothed > (baselineZ + JUMP_OFF_TRAMPOLINE_THRESHOLD_METERS) && verticalVelocitySmoothed > TAKEOFF_VELOCITY_THRESHOLD) {
                  jumpState = JUMP_STATE_AIRBORNE;
                  takeOffTime = currentTime;
                  highestPointZ = currentZSmoothed; // Initialize highest point with current smoothed Z
                  flightTime = 0;
                  if (debugMode) console.log(`[${currentTime.toFixed(0)}ms] Take-off detected!`);
              }
              sendJumpHeight(0, true); // Still on trampoline, send 0 height
              break;

          case JUMP_STATE_AIRBORNE:
              // Condition to go Descending: Vertical velocity becomes negative (past peak)
              if (verticalVelocitySmoothed < PEAK_VELOCITY_THRESHOLD) {
                  jumpState = JUMP_STATE_DESCENDING;
                  if (debugMode) console.log(`[${currentTime.toFixed(0)}ms] Peak/Descending detected.`);
              }
              // highestPointZ is updated continuously in global scope
              break;

          case JUMP_STATE_DESCENDING:
              // Condition to go On Trampoline: Z is back near baseline AND vertical velocity is low/positive (landing impact)
              // Use slightly different threshold for landing (hysteresis)
              if (currentZSmoothed <= (baselineZ + LANDING_ON_TRAMPOLINE_THRESHOLD_METERS) && verticalVelocitySmoothed > LANDING_VELOCITY_THRESHOLD) {
                  jumpState = JUMP_STATE_ON_TRAMPOLINE;
                  const landingTime = currentTime;
                  flightTime = (landingTime - takeOffTime) / 1000;

                  const calculatedJumpHeightFlight = (0.5 * GRAVITY * (flightTime / 2) * (flightTime / 2));
                  let finalReportedHeight = Math.max(0, calculatedJumpHeightFlight < MIN_JUMP_DISPLAY_THRESHOLD ? 0 : calculatedJumpHeightFlight);

                  // --- Z-Scale Factor Automation Logic ---
                  // Only calibrate with meaningful jumps (sufficient flight time)
                  if (currentCalibrationPhase === CALIBRATION_PHASE_JUMP_CALIBRATION && flightTime > 0.3) {
                      const current3DHeight = Math.max(0, highestPointZ - baselineZ); // Height derived from MediaPipe Z

                      if (current3DHeight > 0.01 && calculatedJumpHeightFlight > 0.01) { // Avoid division by zero/near zero
                          calibrationJumpsData.push({ h3d: current3DHeight, hflight: calculatedJumpHeightFlight });
                          console.log(`Calibration Jump ${calibrationJumpsData.length}: H3D=${current3DHeight.toFixed(2)}m, HFlight=${calculatedJumpHeightFlight.toFixed(2)}m`);
                          trampolineNotice.textContent = `Jump ${calibrationJumpsData.length} of ${REQUIRED_CALIBRATION_JUMPS} recorded. Keep jumping!`;
                          
                          if (calibrationJumpsData.length >= REQUIRED_CALIBRATION_JUMPS) {
                              // Calculate average ratio and update depthScaleFactor
                              let sumRatios = 0;
                              for (const data of calibrationJumpsData) {
                                  sumRatios += data.hflight / data.h3d;
                              }
                              const averageRatio = sumRatios / calibrationJumpsData.length;
                              depthScaleFactor *= averageRatio; // Adjust depthScaleFactor
                              depthScaleFactorInput.value = depthScaleFactor.toFixed(1); // Update UI
                              saveSettingsToStorage(); // Save the new factor

                              currentCalibrationPhase = CALIBRATION_PHASE_COMPLETE;
                              calibrationReady = true;
                              trampolineNotice.style.color = '#0f0';
                              trampolineNotice.textContent = "Z-Scale calibrated! Jump height tracking active.";
                              console.log(`Automated depthScaleFactor updated to: ${depthScaleFactor.toFixed(1)}`);
                              calibrationJumpsData = []; // Clear for next potential recalibration
                          }
                      } else {
                          trampolineNotice.textContent = `Jump too small for calibration or invalid height data. Please jump higher. (${calibrationJumpsData.length}/${REQUIRED_CALIBRATION_JUMPS})`;
                          console.warn(`[CALIBRATION_JUMP] Jump too small or invalid for calibration. H3D: ${current3DHeight.toFixed(2)}, HFlight: ${calculatedJumpHeightFlight.toFixed(2)}`);
                      }
                  }

                  if (debugMode) {
                      console.log(`[${currentTime.toFixed(0)}ms] Landing detected! Flight Time: ${flightTime.toFixed(3)}s, Calculated Height: ${calculatedJumpHeightFlight.toFixed(2)}m`);
                      debugValuesDisplay.innerHTML += `Flight Time: ${flightTime.toFixed(3)}s<br>`;
                      debugValuesDisplay.innerHTML += `Calculated Height: ${calculatedJumpHeightFlight.toFixed(2)}m<br>`;
                      debugValuesDisplay.innerHTML += `H3D (peak-baseline): ${(highestPointZ - baselineZ).toFixed(2)}m<br>`;
                  }
                  sendJumpHeight(finalReportedHeight, true);

                  highestPointZ = -Infinity; // Reset for next jump
              }
              break;
      }
    }

    let lastSentJumpHeight = -1;

    function sendJumpHeight(height, calibratedStatus) {
        if (Math.abs(height - lastSentJumpHeight) > 0.005 || (height === 0 && lastSentJumpHeight !== 0)) {
            lastSentJumpHeight = height;
            window.parent.postMessage({
                type: 'jump_height',
                height: height,
                calibrated: calibratedStatus,
                hd_deduction: 0 // Keep for compatibility if used elsewhere
            }, '*');
        }
    }

    // Processing interval for jump height calculation (at a lower rate than MP results for performance)
    setInterval(() => {
      // Only process pose if we are in a tracking or jump calibration phase and have results
      if ((currentCalibrationPhase === CALIBRATION_PHASE_COMPLETE || currentCalibrationPhase === CALIBRATION_PHASE_JUMP_CALIBRATION) && lastPoseResults && lastPoseResults.poseLandmarks && lastPoseResults.poseLandmarks.length > 0) {
        computeAndSendJump(lastPoseResults.poseLandmarks);
      } else {
        // If not in a processing phase or no valid landmarks, ensure smoothing state is reset
        // This is important if we go from a tracked state to a non-tracked state
        if (currentZSmoothed !== null) {
            currentZSmoothed = null;
            verticalVelocitySmoothed = null;
            if (debugMode) console.log("[COMPUTE_LOOP] Resetting smoothed values due to non-tracking state or no landmarks.");
        }
      }
    }, 33); // Approximately 30 FPS for jump logic, balancing accuracy and performance

    // Initialize MediaPipe Pose and start camera
    initializePose().then(() => {
        startCamera();
        detectionLoop();
    });
</script>
</body>
</html>
