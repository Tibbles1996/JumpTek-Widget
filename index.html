<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const switchCameraBtn = document.getElementById('switchCameraBtn');

  let currentStream = null;
  let useFrontCamera = false; // false = rear, true = front
  let isJumping = false;
  let jumpStart = 0;
  let animationFrameId;

  const pose = new Pose({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
  });

  pose.setOptions({
    modelComplexity: 0,
    smoothLandmarks: true,
    enableSegmentation: false
  });

  pose.onResults(onResults);

  async function startCamera() {
    if (currentStream) {
      currentStream.getTracks().forEach(track => track.stop());
    }
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    const constraints = {
      audio: false,
      video: {
        facingMode: useFrontCamera ? 'user' : 'environment',
        width: { ideal: 1280 },
        height: { ideal: 720 },
        aspectRatio: 9 / 16,
        frameRate: { ideal: 30 }
      }
    };

    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      currentStream = stream;
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        video.addEventListener('playing', processVideoFrame, { once: true });
      };
    } catch (err) {
      alert('Unable to access camera.');
      console.error('Camera error:', err);
    }
  }

  async function processVideoFrame() {
    if (video.paused || video.ended) {
      return;
    }
    await pose.send({ image: video });
    animationFrameId = requestAnimationFrame(processVideoFrame);
  }

  function updateStatsDisplay(airtime, height) {
    parent.postMessage({
      type: 'jump',
      airtime,
      height
    }, '*');
  }

  function onResults(results) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (results.poseLandmarks) {
      drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#0FF', lineWidth: 3 });
      drawLandmarks(ctx, results.poseLandmarks, { color: '#FF0', radius: 4 });

      const leftAnkle = results.poseLandmarks[27];
      const rightAnkle = results.poseLandmarks[28];

      const now = performance.now();
      const canvasX = canvas.width;
      const canvasY = canvas.height;

      const footInTrampoline = (pt) => {
        const x = pt.x * canvasX;
        const y = pt.y * canvasY;
        const inX = x > 0.1 * canvasX && x < 0.9 * canvasX;
        const inY = y > 0.4 * canvasY && y < 0.9 * canvasY;
        return inX && inY;
      };

      const leftOn = footInTrampoline(leftAnkle);
      const rightOn = footInTrampoline(rightAnkle);
      const isOnTrampoline = leftOn && rightOn;

      // Detect takeoff: when both ankles leave trampoline area
      if (!isJumping && !isOnTrampoline) {
        isJumping = true;
        jumpStart = now;
      }

      // Detect landing: when both ankles return to trampoline area
      if (isJumping && isOnTrampoline) {
        isJumping = false;
        const airtime = (now - jumpStart) / 1000;

        // Jump height is now a direct function of airtime only:
        const height = 0.6 * airtime; // Adjust 0.6 as needed for realism

        updateStatsDisplay(airtime, height);
      }
    }

    ctx.restore();
  }

  // Switch camera logic: toggles between front and rear using facingMode for iOS compatibility
  switchCameraBtn.addEventListener('click', async () => {
    useFrontCamera = !useFrontCamera;
    await startCamera();
  });

  // On load: start with the rear (environment) camera
  (async () => {
    await startCamera();
  })();
</script>
